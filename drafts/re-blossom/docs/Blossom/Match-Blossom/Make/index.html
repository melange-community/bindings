<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Make (Blossom.Match-Blossom.Make)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../">Up</a> – <a href="../../">Blossom</a> &#x00BB; <a href="../">Match-Blossom</a> &#x00BB; Make</nav><h1>Module <code>Match-Blossom.Make</code></h1><p>Functor building an implementation of the blossom algorithmstructure given a totally ordered type.</p><nav class="toc"><ul><li><a href="#functions">Functions</a></li></ul></nav></header><h3 class="heading">Parameters</h3><ul><li><code><a href="argument-1-Ord">Ord</a>: <a href="..#module-type-OrderedType">OrderedType</a></code></li></ul><h3 class="heading">Signature</h3><dl><dt class="spec type" id="type-vertex"><a href="#type-vertex" class="anchor"></a><code><span class="keyword">type</span> vertex</code><code> = <a href="argument-1-Ord#type-t">Ord.t</a></code>;</dt><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code>;</dt><dd><p>A bi-directional, read-only mapping of each vertex to its mate vertex.</p></dd></dl><section><header><h3 id="functions"><a href="#functions" class="anchor"></a>Functions</h3></header><dl><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">let</span> make: ?&#8288;cardinality:<a href="..#type-cardinality">cardinality</a> <span>=&gt;</span> list((<a href="#type-vertex">vertex</a>, <a href="#type-vertex">vertex</a>, float)) <span>=&gt;</span> <a href="#type-t">t</a>;</code></dt><dd><p>Computes a maximum-weighted matching on a general undirected weighted graph. This function takes time O(n³). See <a href="..#usage"><span>Usage</span></a> for examples of its use.</p><p>Accepts a list of tuples <code>(i, j, w)</code>, each describing an undirected edge between vertex <code>i</code> and vertex <code>j</code> with weight <code>w</code>. There is at most one edge between any two vertices, and no vertex has an edge to itself. Duplicate edges are ignored.</p><dl><dt>parameter cardinality</dt><dd><p>When set to <code>`Max</code>, only maximum-cardinality matchings are considered as solutions. <code>`NotMax</code> is the default.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">let</span> find: <a href="#type-t">t</a> <span>=&gt;</span> <a href="#type-vertex">vertex</a> <span>=&gt;</span> <a href="#type-vertex">vertex</a>;</code></dt><dd><p>Returns <code>mate</code> for a mated vertex, or raises <code>Not_found</code> if no such binding exists.</p></dd></dl><dl><dt class="spec value" id="val-find_opt"><a href="#val-find_opt" class="anchor"></a><code><span class="keyword">let</span> find_opt: <a href="#type-t">t</a> <span>=&gt;</span> <a href="#type-vertex">vertex</a> <span>=&gt;</span> option(<a href="#type-vertex">vertex</a>);</code></dt><dd><p>Returns <code>Some(mate)</code> for a mated vertex, or <code>None</code> if none exists.</p></dd></dl><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">let</span> fold: <a href="#type-t">t</a> <span>=&gt;</span> init:<span class="type-var">'acc</span> <span>=&gt;</span> f:(<span class="type-var">'acc</span> <span>=&gt;</span> <a href="#type-vertex">vertex</a> <span>=&gt;</span> <a href="#type-vertex">vertex</a> <span>=&gt;</span> <span class="type-var">'acc</span>) <span>=&gt;</span> <span class="type-var">'acc</span>;</code></dt><dd><p>Folds over the pairs of vertex mates. Each pair is used twice, once in each order.</p></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">let</span> iter: <a href="#type-t">t</a> <span>=&gt;</span> f:(<a href="#type-vertex">vertex</a> <span>=&gt;</span> <a href="#type-vertex">vertex</a> <span>=&gt;</span> unit) <span>=&gt;</span> unit;</code></dt><dd><p>Iterates over the pairs of vertex mates. Each pair is used twice, once in each order.</p></dd></dl><dl><dt class="spec value" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span class="keyword">let</span> to_list: <a href="#type-t">t</a> <span>=&gt;</span> list((<a href="#type-vertex">vertex</a>, <a href="#type-vertex">vertex</a>));</code></dt><dd><p>Returns a list of tuples for each pair of vertex mates. Each pair is used twice, once in each order.</p></dd></dl><dl><dt class="spec value" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span class="keyword">let</span> is_empty: <a href="#type-t">t</a> <span>=&gt;</span> bool;</code></dt><dd><p>Returns <code>true</code> if there are no mates, <code>false</code> otherwise.</p></dd></dl><dl><dt class="spec value" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span class="keyword">let</span> mem: <a href="#type-vertex">vertex</a> <span>=&gt;</span> <a href="#type-t">t</a> <span>=&gt;</span> bool;</code></dt><dd><p>Returns <code>true</code> if the vertex has a mate, <code>false</code> otherwise.</p></dd></dl><dl><dt class="spec value" id="val-enable_debug"><a href="#val-enable_debug" class="anchor"></a><code><span class="keyword">let</span> enable_debug: (<a href="#type-vertex">vertex</a> <span>=&gt;</span> string) <span>=&gt;</span> unit;</code></dt><dd><p>Calling this with a <code>show</code> or <code>to_string</code> function will enable debug logging.</p></dd></dl><dl><dt class="spec value" id="val-disable_debug"><a href="#val-disable_debug" class="anchor"></a><code><span class="keyword">let</span> disable_debug: unit <span>=&gt;</span> unit;</code></dt></dl></section></div></body></html>