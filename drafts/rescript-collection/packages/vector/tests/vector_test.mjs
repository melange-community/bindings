// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Zora from "@dusty-phillips/rescript-zora/src/Zora.mjs";
import * as Zora$1 from "zora";
import * as Vector from "../src/Vector.mjs";
import * as Js_math from "@rescript/std/lib/es6/js_math.js";
import * as Caml_obj from "@rescript/std/lib/es6/caml_obj.js";
import * as Belt_Array from "@rescript/std/lib/es6/belt_Array.js";
import * as Caml_int32 from "@rescript/std/lib/es6/caml_int32.js";
import * as FastCheck from "fast-check";

function isomorphic(ar) {
  return Caml_obj.equal(Vector.toArray(Vector.fromArray(ar)), ar);
}

function pushpop(n, m) {
  var v = Vector.fromArray(Belt_Array.range(1, n));
  return Belt_Array.reduce(Belt_Array.range(1, m), v, (function (v, param) {
                return Vector.pop(v);
              }));
}

Zora$1.test("Vector initialize", (function (t) {
        t.equal(Vector.length(Vector.make(undefined)), 0, "make empty vector");
        t.equal(Vector.fromArray([]), Vector.make(undefined), "make from empty array");
        Belt_Array.forEach(Belt_Array.range(1, 32), (function (n) {
                t.ok(isomorphic(Belt_Array.range(1, n)), "fromArray length=" + String(n) + "");
              }));
        Belt_Array.forEach(Belt_Array.rangeBy(1000, 10000, 1000), (function (n) {
                t.ok(isomorphic(Belt_Array.range(1, n)), "fromArray length=" + String(n) + "");
              }));
        return Zora.done(undefined);
      }));

Zora$1.test("Vector.push", (function (t) {
        t.test("push", (function (t) {
                Belt_Array.forEach(Belt_Array.range(1, 64), (function (n) {
                        var v1 = Belt_Array.reduce(Belt_Array.range(1, n), Vector.make(undefined), Vector.push);
                        var v2 = Vector.fromArray(Belt_Array.range(1, n));
                        t.equal(v1, v2, "should be equal");
                      }));
                return Zora.done(undefined);
              }));
        t.test("root overflow", (function (t) {
                var v1 = Belt_Array.reduce(Belt_Array.range(1, 32768), Vector.make(undefined), Vector.push);
                var v2 = Vector.fromArray(Belt_Array.range(1, 32768));
                t.equal(v1, v2, "should be equal");
                return Zora.done(undefined);
              }));
        return Zora.done(undefined);
      }));

Zora$1.test("Vector.pop", (function (t) {
        t.test("pop", (function (t) {
                Belt_Array.forEach([
                      [
                        100,
                        50
                      ],
                      [
                        100,
                        100
                      ],
                      [
                        10000,
                        5000
                      ]
                    ], (function (param) {
                        var m = param[1];
                        var n = param[0];
                        t.equal(Vector.toArray(pushpop(n, m)), Belt_Array.range(1, n - m | 0), "should be equal");
                      }));
                return Zora.done(undefined);
              }));
        t.test("root overflow", (function (t) {
                var ar = Belt_Array.range(1, 32768);
                var v = Vector.fromArray(ar);
                var ev = Belt_Array.reduce(ar, v, (function (v, param) {
                        return Vector.pop(v);
                      }));
                t.ok(Vector.length(ev) === 0, "should be empty");
                return Zora.done(undefined);
              }));
        return Zora.done(undefined);
      }));

Zora$1.test("Vector.get", (function (t) {
        var v = pushpop(20000, 10000);
        t.test("random access (10,000 times)", (function (t) {
                var every = Belt_Array.every(Belt_Array.range(1, 10000), (function (param) {
                        var idx = Js_math.random_int(0, 10000);
                        return Vector.getExn(v, idx) === (idx + 1 | 0);
                      }));
                t.ok(every, "should be succeed");
              }));
        t.test("tail offset 0", (function (t) {
                var v = Vector.push(Vector.make(undefined), 1);
                var v$p = Vector.setUnsafe(v, 0, 2);
                t.is(Vector.getUnsafe(v$p, 0), 2, "should be 2");
              }));
        t.test("optional get", (function (t) {
                Belt_Array.forEach([
                      -1,
                      0,
                      10000
                    ], (function (idx) {
                        var match = Vector.get(v, idx);
                        if (match !== undefined) {
                          t.ok(idx >= 0 && idx < Vector.length(v), "should be ok");
                        } else {
                          t.notOk(idx >= 0 && idx < Vector.length(v), "should not be ok");
                        }
                      }));
              }));
        t.test("out of bounds", (function (t) {
                Zora.optionNone(t, Vector.get(v, -1), "should be none");
                Zora.optionNone(t, Vector.get(v, 10000), "should be none");
              }));
        return Zora.done(undefined);
      }));

Zora$1.test("Vector.set", (function (t) {
        var v = Vector.fromArray(Belt_Array.range(1, 10000));
        t.test("random update (" + 10000 + " items)", (function (t) {
                var ar = Belt_Array.shuffle(Belt_Array.range(1, 10000));
                var v$p = Belt_Array.reduce(ar, v, (function (v, idx) {
                        return Vector.setExn(v, idx - 1 | 0, Math.imul(idx, -1));
                      }));
                var every = Belt_Array.every(Vector.toArray(v$p), (function (x) {
                        return x < 0;
                      }));
                t.ok(every, "shoud be ok");
              }));
        t.test("optional set", (function (t) {
                Belt_Array.forEach([
                      -1,
                      0,
                      10000
                    ], (function (idx) {
                        var match = Vector.set(v, idx, 42);
                        if (match !== undefined) {
                          t.ok(idx >= 0 && idx < Vector.length(v), "should be ok");
                        } else {
                          t.notOk(idx >= 0 && idx < Vector.length(v), "should not be ok");
                        }
                      }));
              }));
        var ar = Belt_Array.range(1, 10000);
        t.test("mutable random update (" + 10000 + " times)", (function (t) {
                Belt_Array.forEach(Belt_Array.shuffle(Belt_Array.range(1, 10000)), (function (idx) {
                        ar[idx - 1 | 0] = Math.imul(idx, -1);
                      }));
                var every = Belt_Array.every(ar, (function (x) {
                        return x < 0;
                      }));
                t.ok(every, "should be ok");
              }));
        return Zora.done(undefined);
      }));

Zora$1.test("Vector.reduce", (function (t) {
        var v = Vector.fromArray(Belt_Array.range(1, 100));
        t.test("sum", (function (t) {
                var sum = Vector.reduce(v, 0, (function (acc, i) {
                        return acc + i | 0;
                      }));
                t.is(sum, 5050, "sum is 5050");
              }));
        t.test("sum (uncurried)", (function (t) {
                var sum = Vector.reduceU(v, 0, (function (acc, i) {
                        return acc + i | 0;
                      }));
                t.is(sum, 5050, "sum is 5050");
              }));
        return Zora.done(undefined);
      }));

Zora$1.test("Prop test: should always equally sized", (function (t) {
        var p1 = FastCheck.array(FastCheck.integer(), 0, 10000);
        var p2 = FastCheck.integer(2, 10);
        FastCheck.assert(FastCheck.property(p1, p2, (function (xs, prob) {
                    var a = [];
                    var v = {
                      contents: Vector.make(undefined)
                    };
                    Belt_Array.forEach(xs, (function (n) {
                            v.contents = Caml_int32.mod_(n, prob) !== 0 ? (a.push(n), Vector.push(v.contents, n)) : (a.pop(), Vector.pop(v.contents));
                            if (!Caml_obj.equal(a, Vector.toArray(v.contents))) {
                              throw {
                                    RE_EXN_ID: "Assert_failure",
                                    _1: [
                                      "vector_test.res",
                                      184,
                                      10
                                    ],
                                    Error: new Error()
                                  };
                            }
                            if (a.length === Vector.length(v.contents)) {
                              return ;
                            }
                            throw {
                                  RE_EXN_ID: "Assert_failure",
                                  _1: [
                                    "vector_test.res",
                                    185,
                                    10
                                  ],
                                  Error: new Error()
                                };
                          }));
                    t.equal(a.length, Vector.length(v.contents), "equal length");
                    return a.length === Vector.length(v.contents);
                  })));
        return Zora.done(undefined);
      }));

var A;

var V;

export {
  A ,
  V ,
  isomorphic ,
  pushpop ,
}
/*  Not a pure module */
