// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Bvt from "./impl/Bvt.mjs";
import * as Curry from "@rescript/std/lib/es6/curry.js";
import * as Belt_Array from "@rescript/std/lib/es6/belt_Array.js";
import * as Caml_option from "@rescript/std/lib/es6/caml_option.js";

function makeBy(size, f) {
  return Bvt.makeByU(size, Curry.__1(f));
}

function length(v) {
  return v.size;
}

function size(v) {
  return v.size;
}

function get(v, i) {
  if (i < 0 || i >= v.size) {
    return ;
  } else {
    return Caml_option.some(Bvt.getUnsafe(v, i));
  }
}

function getExn(v, i) {
  if (!(i >= 0 && i < v.size)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "Vector.res",
            17,
            2
          ],
          Error: new Error()
        };
  }
  return Bvt.getUnsafe(v, i);
}

function getByU(vec, pred) {
  var i = 0;
  var r;
  while(r === undefined && i < vec.size) {
    var ar = Bvt.getLeafUnsafe(vec, i);
    var len = ar.length;
    for(var j = 0; j < len; ++j){
      var v = ar[j];
      if (pred(v)) {
        r = Caml_option.some(v);
      }
      
    }
    i = i + len | 0;
  };
  return r;
}

function getBy(vec, pred) {
  return getByU(vec, Curry.__1(pred));
}

function getIndexByU(vec, pred) {
  var i = 0;
  var r;
  while(r === undefined && i < vec.size) {
    var ar = Bvt.getLeafUnsafe(vec, i);
    var len = ar.length;
    for(var j = 0; j < len; ++j){
      var v = ar[j];
      if (pred(v)) {
        r = i;
      }
      i = i + 1 | 0;
    }
  };
  return r;
}

function getIndexBy(vec, pred) {
  return getIndexByU(vec, Curry.__1(pred));
}

function set(vec, i, x) {
  if (i < 0 || i >= vec.size) {
    return ;
  } else {
    return Bvt.setUnsafe(vec, i, x);
  }
}

function setExn(vec, i, x) {
  if (!(i >= 0 && i < vec.size)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "Vector.res",
            67,
            2
          ],
          Error: new Error()
        };
  }
  return Bvt.setUnsafe(vec, i, x);
}

function reduceU(vec, init, f) {
  var i = 0;
  var acc = init;
  while(i < vec.size) {
    var ar = Bvt.getLeafUnsafe(vec, i);
    var len = ar.length;
    for(var j = 0; j < len; ++j){
      acc = f(acc, ar[j]);
    }
    i = i + len | 0;
  };
  return acc;
}

function reduce(vec, init, f) {
  return reduceU(vec, init, Curry.__2(f));
}

function reduceWithIndexU(vec, init, f) {
  var i = 0;
  var acc = init;
  while(i < vec.size) {
    var ar = Bvt.getLeafUnsafe(vec, i);
    var len = ar.length;
    for(var j = 0; j < len; ++j){
      acc = f(acc, ar[j], i);
      i = i + 1 | 0;
    }
  };
  return acc;
}

function reduceWithIndex(vec, init, f) {
  return reduceWithIndexU(vec, init, Curry.__3(f));
}

function mapU(vec, f) {
  return reduceU(vec, Bvt.make(undefined), (function (res, v) {
                return Bvt.push(res, f(v));
              }));
}

function map(vec, f) {
  return mapU(vec, Curry.__1(f));
}

function mapWithIndexU(vec, f) {
  return reduceWithIndexU(vec, Bvt.make(undefined), (function (res, v, i) {
                return Bvt.push(res, f(v, i));
              }));
}

function mapWithIndex(vec, f) {
  return mapWithIndexU(vec, Curry.__2(f));
}

function keepU(vec, f) {
  return reduceU(vec, Bvt.make(undefined), (function (res, v) {
                if (f(v)) {
                  return Bvt.push(res, v);
                } else {
                  return res;
                }
              }));
}

function keep(vec, f) {
  return keepU(vec, Curry.__1(f));
}

function keepMapU(vec, f) {
  return reduceU(vec, Bvt.make(undefined), (function (acc, v) {
                var v$1 = f(v);
                if (v$1 !== undefined) {
                  return Bvt.push(acc, Caml_option.valFromOption(v$1));
                } else {
                  return acc;
                }
              }));
}

function keepMap(vec, f) {
  return keepMapU(vec, Curry.__1(f));
}

function keepWithIndexU(vec, f) {
  return reduceWithIndexU(vec, Bvt.make(undefined), (function (res, v, i) {
                if (f(v, i)) {
                  return Bvt.push(res, v);
                } else {
                  return res;
                }
              }));
}

function keepWithIndex(vec, f) {
  return keepWithIndexU(vec, Curry.__2(f));
}

function forEachU(vec, f) {
  var i = 0;
  while(i < vec.size) {
    var ar = Bvt.getLeafUnsafe(vec, i);
    var len = ar.length;
    for(var j = 0; j < len; ++j){
      f(ar[j]);
    }
    i = i + len | 0;
  };
}

function forEach(vec, f) {
  forEachU(vec, Curry.__1(f));
}

function forEachWithIndexU(vec, f) {
  var i = 0;
  while(i < vec.size) {
    var ar = Bvt.getLeafUnsafe(vec, i);
    var len = ar.length;
    for(var j = 0; j < len; ++j){
      f(ar[j], i);
      i = i + 1 | 0;
    }
  };
}

function forEachWithIndex(vec, f) {
  forEachWithIndexU(vec, Curry.__2(f));
}

function someU(vec, f) {
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === vec.size) {
      return false;
    }
    if (f(Bvt.getUnsafe(vec, i))) {
      return true;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function some(vec, f) {
  return someU(vec, Curry.__1(f));
}

function everyU(vec, f) {
  var _i = 0;
  var len = vec.size;
  while(true) {
    var i = _i;
    if (i === len) {
      return true;
    }
    if (!f(Bvt.getUnsafe(vec, i))) {
      return false;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function every(vec, f) {
  return everyU(vec, Curry.__1(f));
}

function everyAux2(v1, v2, _i, f, len) {
  while(true) {
    var i = _i;
    if (i === len) {
      return true;
    }
    if (!f(Bvt.getUnsafe(v1, i), Bvt.getUnsafe(v2, i))) {
      return false;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function some2U(v1, v2, f) {
  var _i = 0;
  var len = v1.size < v2.size ? v1.size : v2.size;
  while(true) {
    var i = _i;
    if (i === len) {
      return false;
    }
    if (f(Bvt.getUnsafe(v1, i), Bvt.getUnsafe(v2, i))) {
      return true;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function some2(v1, v2, f) {
  return some2U(v1, v2, Curry.__2(f));
}

function every2U(v1, v2, f) {
  return everyAux2(v1, v2, 0, f, v1.size < v2.size ? v1.size : v2.size);
}

function every2(v1, v2, f) {
  return every2U(v1, v2, Curry.__2(f));
}

function cmpU(v1, v2, f) {
  var len1 = v1.size;
  var len2 = v2.size;
  if (len1 > len2) {
    return 1;
  } else if (len1 < len2) {
    return -1;
  } else {
    var _i = 0;
    while(true) {
      var i = _i;
      if (i === len1) {
        return 0;
      }
      var c = f(Bvt.getUnsafe(v1, i), Bvt.getUnsafe(v2, i));
      if (c !== 0) {
        return c;
      }
      _i = i + 1 | 0;
      continue ;
    };
  }
}

function cmp(v1, v2, f) {
  return cmpU(v1, v2, Curry.__2(f));
}

function eqU(v1, v2, f) {
  var len1 = v1.size;
  var len2 = v2.size;
  if (len1 === len2) {
    return everyAux2(v1, v2, 0, f, len1);
  } else {
    return false;
  }
}

function eq(v1, v2, f) {
  return eqU(v1, v2, Curry.__2(f));
}

function zipByU(v1, v2, f) {
  var len = v1.size < v2.size ? v1.size : v2.size;
  var i = 0;
  var r = Bvt.make(undefined);
  while(i < len) {
    var ar1 = Bvt.getLeafUnsafe(v1, i);
    var ar2 = Bvt.getLeafUnsafe(v2, i);
    var l = ar1.length;
    for(var j = 0; j < l; ++j){
      r = Bvt.push(r, f(ar1[j], ar2[j]));
    }
    i = i + l | 0;
  };
  return r;
}

function zipBy(v1, v2, f) {
  return zipByU(v1, v2, Curry.__2(f));
}

function zip(v1, v2) {
  return zipByU(v1, v2, (function (a, b) {
                return [
                        a,
                        b
                      ];
              }));
}

function unzip(vec) {
  return reduceU(vec, [
              Bvt.make(undefined),
              Bvt.make(undefined)
            ], (function (param, param$1) {
                return [
                        Bvt.push(param[0], param$1[0]),
                        Bvt.push(param[1], param$1[1])
                      ];
              }));
}

function sortU(vec, f) {
  return Bvt.fromArray(Bvt.toArray(vec).sort(function (a, b) {
                  return f(a, b);
                }));
}

function sort(vec, f) {
  return Bvt.fromArray(Bvt.toArray(vec).sort(Curry.__2(f)));
}

function reverse(vec) {
  return Bvt.fromArray(Bvt.toArray(vec).reverse());
}

function shuffle(vec) {
  var ar = Bvt.toArray(vec);
  Belt_Array.shuffleInPlace(ar);
  return Bvt.fromArray(ar);
}

function concat(to_, from) {
  return reduceU(from, to_, Bvt.push);
}

function concatMany(vs) {
  return vs.reduce((function (acc, v) {
                return reduceU(v, acc, Bvt.push);
              }), Bvt.make(undefined));
}

function pushMany(to_, from) {
  return from.reduce(Bvt.push, to_);
}

var make = Bvt.make;

var makeByU = Bvt.makeByU;

var push = Bvt.push;

var pop = Bvt.pop;

var getUnsafe = Bvt.getUnsafe;

var setUnsafe = Bvt.setUnsafe;

var fromArray = Bvt.fromArray;

var toArray = Bvt.toArray;

export {
  make ,
  makeByU ,
  makeBy ,
  length ,
  size ,
  concat ,
  concatMany ,
  push ,
  pushMany ,
  pop ,
  get ,
  getExn ,
  getUnsafe ,
  getByU ,
  getBy ,
  getIndexByU ,
  getIndexBy ,
  set ,
  setExn ,
  setUnsafe ,
  reduceU ,
  reduce ,
  reduceWithIndexU ,
  reduceWithIndex ,
  mapU ,
  map ,
  mapWithIndexU ,
  mapWithIndex ,
  keepU ,
  keep ,
  keepMapU ,
  keepMap ,
  keepWithIndexU ,
  keepWithIndex ,
  forEachU ,
  forEach ,
  forEachWithIndexU ,
  forEachWithIndex ,
  someU ,
  some ,
  some2U ,
  some2 ,
  everyU ,
  every ,
  every2U ,
  every2 ,
  cmpU ,
  cmp ,
  eqU ,
  eq ,
  zip ,
  zipByU ,
  zipBy ,
  unzip ,
  sortU ,
  sort ,
  reverse ,
  shuffle ,
  fromArray ,
  toArray ,
}
/* No side effect */
