// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Char = require("rescript/lib/js/char.js");
var Belt_List = require("rescript/lib/js/belt_List.js");
var Res_parser = require("../../src/res_parser.cjs");
var Belt_Option = require("rescript/lib/js/belt_Option.js");

function charListToString(chars) {
  return Belt_List.reduce(Belt_List.map(chars, Char.escaped), "", (function (prim0, prim1) {
                return prim0.concat(prim1);
              }));
}

var whitespace = Res_parser.satisfy(function ($$char) {
      if ($$char > 13 || $$char < 9) {
        return $$char === 32;
      } else {
        return !($$char === 12 || $$char === 11);
      }
    });

var manyWhitespace = Res_parser.many(whitespace);

function toString(t) {
  switch (t.TAG | 0) {
    case /* Int */0 :
        return "Int(" + t._0 + ")";
    case /* String */1 :
        return "String(\"" + t._0 + "\")";
    case /* Exp */2 :
        var loop = function (lst) {
          if (lst) {
            return toString(lst.hd) + ", " + loop(lst.tl);
          } else {
            return "";
          }
        };
        return "Exp(" + loop(t._0) + ")";
    
  }
}

var doubleQuote = Res_parser.$$char(/* '"' */34);

var anyChar = Res_parser.satisfy(function ($$char) {
      return $$char !== /* '"' */34;
    });

var quotedString = Res_parser.map(Res_parser.map(Res_parser.between(Res_parser.many(anyChar), doubleQuote, doubleQuote), charListToString), (function (s) {
        return {
                TAG: /* String */1,
                _0: s
              };
      }));

var digit = Res_parser.satisfy(function ($$char) {
      if ($$char >= /* '0' */48) {
        return /* '9' */57 >= $$char;
      } else {
        return false;
      }
    });

var $$int = Res_parser.map(Res_parser.map(Res_parser.andThen(Res_parser.map(Res_parser.map(Res_parser.optional(Res_parser.$$char(/* '-' */45)), (function (__x) {
                        return Belt_Option.map(__x, Char.escaped);
                      })), (function (__x) {
                    return Belt_Option.getWithDefault(__x, "");
                  })), Res_parser.map(Res_parser.atLeastOne(digit), charListToString)), (function (param) {
            return param[0] + param[1];
          })), (function (i) {
        return {
                TAG: /* Int */0,
                _0: i
              };
      }));

var parser = Res_parser.makeRecursive(function (p) {
      var sexp = Res_parser.between(Res_parser.map(Res_parser.orElse(Res_parser.atLeastOne(p), Res_parser.map(manyWhitespace, (function (param) {
                          return /* [] */0;
                        }))), (function (xs) {
                  return {
                          TAG: /* Exp */2,
                          _0: xs
                        };
                })), Res_parser.$$char(/* '(' */40), Res_parser.$$char(/* ')' */41));
      return Res_parser.between(Res_parser.choice([
                      quotedString,
                      $$int,
                      sexp
                    ]), manyWhitespace, manyWhitespace);
    });

var P;

exports.P = P;
exports.charListToString = charListToString;
exports.whitespace = whitespace;
exports.manyWhitespace = manyWhitespace;
exports.toString = toString;
exports.quotedString = quotedString;
exports.$$int = $$int;
exports.parser = parser;
/* whitespace Not a pure module */
