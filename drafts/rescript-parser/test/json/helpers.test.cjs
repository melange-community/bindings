// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Ava = require("rescript-ava/src/ava.cjs");
var Json = require("./parser/json.cjs");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Range = require("rescript/lib/js/belt_Range.js");
var Res_parser = require("../../src/res_parser.cjs");
var Test_runners = require("../test_runners.cjs");

var remaining = Res_parser.State.remaining;

function shouldNotPass(param) {
  return "Should not pass with \"" + remaining(param[1]) + "\" remaining";
}

var shouldNotFail = "Should not fail";

Ava.test("Digit succeeds", (function (t) {
        return Belt_Range.forEach(0, 9, (function (index) {
                      var asString = String(index);
                      var error = Res_parser.run(Json.digit, asString);
                      if (error.TAG !== /* Ok */0) {
                        return Ava.fail(t, "Failure to parse digit: \"" + error._0.message + "\"", undefined);
                      }
                      var match = error._0;
                      var state = match[1];
                      if (Res_parser.State.remaining(state) === "") {
                        return Ava.true_(t, match[0] === asString, undefined, undefined);
                      } else {
                        return Ava.fail(t, "Parsing digit had remaining characters: \"" + state.input + "\"", undefined);
                      }
                    }));
      }));

Test_runners.runTests(Json.digit, (function (input, param) {
        return "[JSON Digit] Run with \"" + input + "\"";
      }), [
      [
        "10",
        "1",
        "0"
      ],
      [
        "1hello",
        "1",
        "hello"
      ]
    ]);

Test_runners.runFailureTests(Json.digit, (function (input) {
        return "[JSON Digit] Fail with \"" + input + "\"";
      }), ["hello"]);

Test_runners.runTests(Json.digits, (function (input, param) {
        return "[JSON digit] Run with \"" + input + "\"";
      }), [
      [
        "1",
        "1",
        ""
      ],
      [
        "123",
        "123",
        ""
      ],
      [
        "123asdf",
        "123",
        "asdf"
      ]
    ]);

Ava.test("Digits fails", (function (t) {
        var match = Res_parser.run(Json.digit, " 123");
        if (match.TAG === /* Ok */0) {
          Ava.fail(t, undefined, undefined);
        } else {
          Ava.pass(t, undefined, undefined);
        }
        var match$1 = Res_parser.run(Json.digit, "not even close");
        if (match$1.TAG === /* Ok */0) {
          return Ava.fail(t, undefined, undefined);
        } else {
          return Ava.pass(t, undefined, undefined);
        }
      }));

Test_runners.runTests(Json.exponent, (function (input, param) {
        return "[Exponent] \"" + input + "\"";
      }), [
      [
        "e-1234",
        "e-1234",
        ""
      ],
      [
        "E-1234",
        "E-1234",
        ""
      ],
      [
        "e1234",
        "e1234",
        ""
      ],
      [
        "E1234",
        "E1234",
        ""
      ],
      [
        "e0",
        "e0",
        ""
      ],
      [
        "E0",
        "E0",
        ""
      ]
    ]);

Test_runners.runTests(Json.exponent, (function (input, param) {
        return "[Exponent Partial] \"" + input + "\"";
      }), [
      [
        "e-1234hello",
        "e-1234",
        "hello"
      ],
      [
        "e-1234  1",
        "e-1234",
        "  1"
      ]
    ]);

Test_runners.runFailureTests(Json.exponent, (function (input) {
        return "[Exponent fails] \"" + input + "\"";
      }), [
      "  E0",
      "e--1",
      "e-",
      "ye "
    ]);

Test_runners.runTests(Json.fraction, (function (input, param) {
        return "[Fraction succeeds] \"" + input + "\"";
      }), [
      [
        ".1234",
        ".1234",
        ""
      ],
      [
        ".4",
        ".4",
        ""
      ],
      [
        ".0000345",
        ".0000345",
        ""
      ]
    ]);

Ava.test("Fraction partially succeeds", (function (t) {
        var match = Res_parser.run(Json.fraction, ".654hello");
        if (match.TAG === /* Ok */0) {
          var match$1 = match._0;
          if (match$1[0] === ".654" && remaining(match$1[1]) === "hello") {
            Ava.pass(t, undefined, undefined);
          } else {
            Ava.fail(t, undefined, undefined);
          }
        } else {
          Ava.fail(t, undefined, undefined);
        }
        var match$2 = Res_parser.run(Json.fraction, ".1  1");
        if (match$2.TAG !== /* Ok */0) {
          return Ava.fail(t, undefined, undefined);
        }
        var match$3 = match$2._0;
        if (match$3[0] === ".1" && remaining(match$3[1]) === "  1") {
          return Ava.pass(t, undefined, undefined);
        } else {
          return Ava.fail(t, undefined, undefined);
        }
      }));

Test_runners.runFailureTests(Json.fraction, (function (input) {
        return "[Fraction fails] \"" + input + "\"";
      }), [
      "  .1",
      ".e1",
      ". .1",
      "..",
      "..11"
    ]);

Ava.test("Sign succeeds", (function (t) {
        var match = Res_parser.run(Json.sign, "-");
        if (match.TAG === /* Ok */0) {
          var match$1 = match._0;
          if (match$1[0] !== 45 || remaining(match$1[1]) !== "") {
            Ava.fail(t, undefined, undefined);
          } else {
            Ava.pass(t, undefined, undefined);
          }
        } else {
          Ava.fail(t, undefined, undefined);
        }
        var match$2 = Res_parser.run(Json.sign, "+");
        if (match$2.TAG !== /* Ok */0) {
          return Ava.fail(t, undefined, undefined);
        }
        var match$3 = match$2._0;
        if (match$3[0] !== 43 || remaining(match$3[1]) !== "") {
          return Ava.fail(t, undefined, undefined);
        } else {
          return Ava.pass(t, undefined, undefined);
        }
      }));

Ava.test("Sign partially succeeds", (function (t) {
        var match = Res_parser.run(Json.sign, "+1");
        if (match.TAG === /* Ok */0) {
          var match$1 = match._0;
          if (match$1[0] !== 43 || remaining(match$1[1]) !== "1") {
            Ava.fail(t, undefined, undefined);
          } else {
            Ava.pass(t, undefined, undefined);
          }
        } else {
          Ava.fail(t, undefined, undefined);
        }
        var match$2 = Res_parser.run(Json.sign, "-1  1");
        if (match$2.TAG === /* Ok */0) {
          var match$3 = match$2._0;
          if (match$3[0] !== 45 || remaining(match$3[1]) !== "1  1") {
            Ava.fail(t, undefined, undefined);
          } else {
            Ava.pass(t, undefined, undefined);
          }
        } else {
          Ava.fail(t, undefined, undefined);
        }
        var match$4 = Res_parser.run(Json.sign, "+     sdf1  1");
        if (match$4.TAG !== /* Ok */0) {
          return Ava.fail(t, undefined, undefined);
        }
        var match$5 = match$4._0;
        if (match$5[0] !== 43 || remaining(match$5[1]) !== "     sdf1  1") {
          return Ava.fail(t, undefined, undefined);
        } else {
          return Ava.pass(t, undefined, undefined);
        }
      }));

Ava.test("Sign fails", (function (t) {
        var match = Res_parser.run(Json.sign, "  +");
        if (match.TAG === /* Ok */0) {
          Ava.fail(t, undefined, undefined);
        } else {
          Ava.pass(t, undefined, undefined);
        }
        var match$1 = Res_parser.run(Json.sign, "  1-");
        if (match$1.TAG === /* Ok */0) {
          return Ava.fail(t, undefined, undefined);
        } else {
          return Ava.pass(t, undefined, undefined);
        }
      }));

Test_runners.runTests(Json.integer, (function (input, param) {
        return "[Integer succeeds] \"" + input + "\"";
      }), [
      [
        "1",
        "1",
        ""
      ],
      [
        "0",
        "0",
        ""
      ],
      [
        "1234",
        "1234",
        ""
      ],
      [
        "-1",
        "-1",
        ""
      ],
      [
        "-0",
        "-0",
        ""
      ],
      [
        "-10002345",
        "-10002345",
        ""
      ]
    ]);

Ava.test("Integer partially succeeds", (function (t) {
        var match = Res_parser.run(Json.integer, "1ert");
        if (match.TAG === /* Ok */0) {
          var match$1 = match._0;
          if (match$1[0] === "1" && remaining(match$1[1]) === "ert") {
            Ava.pass(t, undefined, undefined);
          } else {
            Ava.fail(t, undefined, undefined);
          }
        } else {
          Ava.fail(t, undefined, undefined);
        }
        var match$2 = Res_parser.run(Json.integer, "-1  1");
        if (match$2.TAG !== /* Ok */0) {
          return Ava.fail(t, undefined, undefined);
        }
        var match$3 = match$2._0;
        if (match$3[0] === "-1" && remaining(match$3[1]) === "  1") {
          return Ava.pass(t, undefined, undefined);
        } else {
          return Ava.fail(t, undefined, undefined);
        }
      }));

Ava.test("Integer fails", (function (t) {
        var match = Res_parser.run(Json.integer, "  +");
        if (match.TAG === /* Ok */0) {
          Ava.fail(t, undefined, undefined);
        } else {
          Ava.pass(t, undefined, undefined);
        }
        var match$1 = Res_parser.run(Json.integer, "  1");
        if (match$1.TAG === /* Ok */0) {
          Ava.fail(t, undefined, undefined);
        } else {
          Ava.pass(t, undefined, undefined);
        }
        var match$2 = Res_parser.run(Json.integer, "  h1-");
        if (match$2.TAG === /* Ok */0) {
          return Ava.fail(t, undefined, undefined);
        } else {
          return Ava.pass(t, undefined, undefined);
        }
      }));

Test_runners.runTests(Json.unescapedChar, (function (input, param) {
        return "[Unescaped char] \"" + input + "\"";
      }), [
      [
        "a",
        "a",
        ""
      ],
      [
        "b",
        "b",
        ""
      ],
      [
        "c",
        "c",
        ""
      ],
      [
        "d",
        "d",
        ""
      ],
      [
        "9",
        "9",
        ""
      ],
      [
        "-",
        "-",
        ""
      ],
      [
        " ",
        " ",
        ""
      ]
    ]);

Test_runners.runTests(Json.unescapedChar, (function (input, param) {
        return "[Unescaped char partial] \"" + input + "\"";
      }), [
      [
        "a\"",
        "a",
        "\""
      ],
      [
        "a\\",
        "a",
        "\\"
      ],
      [
        "a\\\"",
        "a",
        "\\\""
      ]
    ]);

Ava.test("Unescaped char fails", (function (t) {
        var match = Res_parser.run(Json.unescapedChar, "\"");
        if (match.TAG === /* Ok */0) {
          Ava.fail(t, "Should not parse escaped char", undefined);
        } else {
          Ava.pass(t, undefined, undefined);
        }
        var match$1 = Res_parser.run(Json.unescapedChar, "\\");
        if (match$1.TAG === /* Ok */0) {
          return Ava.fail(t, "Should not parse escaped char", undefined);
        } else {
          return Ava.pass(t, undefined, undefined);
        }
      }));

var successes = [
  [
    "\\\"",
    "\""
  ],
  [
    "\\\\",
    "\\"
  ],
  [
    "\\/",
    "/"
  ],
  [
    "\\b",
    "\b"
  ],
  [
    "\\n",
    "\n"
  ],
  [
    "\\r",
    "\r"
  ],
  [
    "\\t",
    "\t"
  ]
];

Belt_Array.forEach(successes, (function (param) {
        var expected = param[1];
        var input = param[0];
        return Ava.test("[Escaped char] \"" + input + "\" succeeds", (function (t) {
                      var err = Res_parser.run(Json.escapedChar, input);
                      if (err.TAG !== /* Ok */0) {
                        return Ava.fail(t, "Should not fail with \"" + err._0.message + "\"", undefined);
                      }
                      var match = err._0;
                      var j = match[0];
                      return Ava.true_(t, j === expected, "Should not succeed with \"" + j + "\" and \"" + remaining(match[1]) + "\" remaining", undefined);
                    }));
      }));

var partialSuccesses = [
  [
    "\\\"  ",
    "\"",
    "  "
  ],
  [
    "\\\\hello",
    "\\",
    "hello"
  ],
  [
    "\\/\\/",
    "/",
    "\\/"
  ],
  [
    "\\b-1234gfd",
    "\b",
    "-1234gfd"
  ],
  [
    "\\n l ll ll \n",
    "\n",
    " l ll ll \n"
  ],
  [
    "\\r\\n",
    "\r",
    "\\n"
  ],
  [
    "\\t\\lll",
    "\t",
    "\\lll"
  ]
];

Belt_Array.forEach(partialSuccesses, (function (param) {
        var remaining_ = param[2];
        var expected = param[1];
        var input = param[0];
        return Ava.test("[Escaped char] \"" + input + "\" partially succeeds", (function (t) {
                      var err = Res_parser.run(Json.escapedChar, input);
                      if (err.TAG !== /* Ok */0) {
                        return Ava.fail(t, "Shouldn't fail with \"" + err._0.message + "\"", undefined);
                      }
                      var match = err._0;
                      var r = match[1];
                      var e = match[0];
                      if (e === expected && remaining(r) === remaining_) {
                        return Ava.pass(t, undefined, undefined);
                      } else {
                        return Ava.fail(t, "Shouldn't succeed with \"" + e + "\" and \"" + remaining(r) + "\" remaining", undefined);
                      }
                    }));
      }));

Test_runners.runFailureTests(Json.escapedChar, (function (input) {
        return "[Escaped char] \"" + input + "\"";
      }), [
      " \"",
      " \\\"",
      "asfds\t"
    ]);

function run(param) {
  return Res_parser.run(Json.unicodeChar, param);
}

Ava.test("Unicode char succeeds", (function (t) {
        var x = Res_parser.run(Json.unicodeChar, "\\u0041");
        if (x.TAG === /* Ok */0) {
          var x$1 = x._0;
          if (x$1[0] === "A" && remaining(x$1[1]) === "") {
            Ava.pass(t, undefined, undefined);
          } else {
            Ava.fail(t, shouldNotPass(x$1), undefined);
          }
        } else {
          Ava.fail(t, shouldNotFail, undefined);
        }
        var x$2 = Res_parser.run(Json.unicodeChar, "\\u0031");
        if (x$2.TAG === /* Ok */0) {
          var x$3 = x$2._0;
          if (x$3[0] === "1" && remaining(x$3[1]) === "") {
            Ava.pass(t, undefined, undefined);
          } else {
            Ava.fail(t, shouldNotPass(x$3), undefined);
          }
        } else {
          Ava.fail(t, shouldNotFail, undefined);
        }
        var x$4 = Res_parser.run(Json.unicodeChar, "\\u0028");
        if (x$4.TAG === /* Ok */0) {
          var x$5 = x$4._0;
          if (x$5[0] === "(" && remaining(x$5[1]) === "") {
            Ava.pass(t, undefined, undefined);
          } else {
            Ava.fail(t, shouldNotPass(x$5), undefined);
          }
        } else {
          Ava.fail(t, shouldNotFail, undefined);
        }
        var x$6 = Res_parser.run(Json.unicodeChar, "\\u0101");
        if (x$6.TAG !== /* Ok */0) {
          return Ava.fail(t, shouldNotFail, undefined);
        }
        var x$7 = x$6._0;
        if (x$7[0] === String.fromCharCode(257)) {
          return Ava.pass(t, undefined, undefined);
        } else {
          return Ava.fail(t, shouldNotPass(x$7), undefined);
        }
      }));

Ava.test("Unicode char partially succeeds", (function (t) {
        var x = Res_parser.run(Json.unicodeChar, "\\u0041asdf");
        if (x.TAG === /* Ok */0) {
          var x$1 = x._0;
          if (x$1[0] === "A" && remaining(x$1[1]) === "asdf") {
            Ava.pass(t, undefined, undefined);
          } else {
            Ava.fail(t, shouldNotPass(x$1), undefined);
          }
        } else {
          Ava.fail(t, shouldNotFail, undefined);
        }
        var x$2 = Res_parser.run(Json.unicodeChar, "\\u0041asdf");
        if (x$2.TAG === /* Ok */0) {
          var x$3 = x$2._0;
          if (x$3[0] === "A" && remaining(x$3[1]) === "asdf") {
            Ava.pass(t, undefined, undefined);
          } else {
            Ava.fail(t, shouldNotPass(x$3), undefined);
          }
        } else {
          Ava.fail(t, shouldNotFail, undefined);
        }
        var x$4 = Res_parser.run(Json.unicodeChar, "\\u0031999");
        if (x$4.TAG === /* Ok */0) {
          var x$5 = x$4._0;
          if (x$5[0] === "1" && remaining(x$5[1]) === "999") {
            Ava.pass(t, undefined, undefined);
          } else {
            Ava.fail(t, shouldNotPass(x$5), undefined);
          }
        } else {
          Ava.fail(t, shouldNotFail, undefined);
        }
        var x$6 = Res_parser.run(Json.unicodeChar, "\\u0028   lol");
        if (x$6.TAG === /* Ok */0) {
          var x$7 = x$6._0;
          if (x$7[0] === "(" && remaining(x$7[1]) === "   lol") {
            Ava.pass(t, undefined, undefined);
          } else {
            Ava.fail(t, shouldNotPass(x$7), undefined);
          }
        } else {
          Ava.fail(t, shouldNotFail, undefined);
        }
        var x$8 = Res_parser.run(Json.unicodeChar, "\\u0101\\u0101");
        if (x$8.TAG !== /* Ok */0) {
          return Ava.fail(t, shouldNotFail, undefined);
        }
        var x$9 = x$8._0;
        if (x$9[0] === String.fromCharCode(257) && remaining(x$9[1]) === "\\u0101") {
          return Ava.pass(t, undefined, undefined);
        } else {
          return Ava.fail(t, shouldNotPass(x$9), undefined);
        }
      }));

Test_runners.runFailureTests(Json.unicodeChar, (function (input) {
        return "[Unicode char] \"" + input + "\"";
      }), [
      "  \\u0041asdf",
      "\\\\u0031999",
      "l\\u0028   lol",
      "/\\u0101\\u0101"
    ]);

var P;

exports.P = P;
exports.remaining = remaining;
exports.shouldNotPass = shouldNotPass;
exports.shouldNotFail = shouldNotFail;
exports.successes = successes;
exports.partialSuccesses = partialSuccesses;
exports.run = run;
/*  Not a pure module */
