// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Char = require("rescript/lib/js/char.js");
var List = require("rescript/lib/js/list.js");
var Curry = require("rescript/lib/js/curry.js");
var Belt_List = require("rescript/lib/js/belt_List.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Pervasives = require("rescript/lib/js/pervasives.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Caml_string = require("rescript/lib/js/caml_string.js");

function make(param) {
  return {
          prevLines: /* [] */0,
          index: 0,
          lineStart: 0,
          line: 1,
          col: 1
        };
}

function newline(t) {
  return {
          prevLines: {
            hd: [
              t.lineStart,
              t.index
            ],
            tl: t.prevLines
          },
          index: t.index + 1 | 0,
          lineStart: t.index + 1 | 0,
          line: t.line + 1 | 0,
          col: 1
        };
}

function next(t) {
  return {
          prevLines: t.prevLines,
          index: t.index + 1 | 0,
          lineStart: t.lineStart,
          line: t.line,
          col: t.col + 1 | 0
        };
}

var Position = {
  make: make,
  newline: newline,
  next: next
};

function getChar(t) {
  try {
    return Caml_string.get(t.input, t.position.index);
  }
  catch (exn){
    return ;
  }
}

function next$1(t) {
  var match = getChar(t);
  if (match !== undefined) {
    if (match !== 10 && match !== 13) {
      return {
              position: next(t.position),
              input: t.input
            };
    } else {
      return {
              position: newline(t.position),
              input: t.input
            };
    }
  } else {
    return t;
  }
}

function getPosition(t) {
  return t.position;
}

function fromString(input) {
  return {
          position: {
            prevLines: /* [] */0,
            index: 0,
            lineStart: 0,
            line: 1,
            col: 1
          },
          input: input
        };
}

function remaining(t) {
  return t.input.slice(t.position.index);
}

function makeFrames(state) {
  var input = state.input;
  var position = state.position;
  var line = position.line;
  var prevLines = position.prevLines;
  var size = Math.min(4, Belt_List.size(prevLines));
  var lines = Belt_List.take(prevLines, size);
  return Belt_List.mapWithIndex(Belt_Option.getWithDefault(lines, /* [] */0), (function (index, param) {
                var lineNumber = (line - index | 0) - 1 | 0;
                return [
                        lineNumber,
                        input.slice(param[0], param[1])
                      ];
              }));
}

var State = {
  getChar: getChar,
  next: next$1,
  getPosition: getPosition,
  fromString: fromString,
  remaining: remaining,
  makeFrames: makeFrames
};

function fromInput(state, message) {
  return {
          message: message,
          state: state
        };
}

var $$Error = {
  fromInput: fromInput
};

function runOnInput(t, input) {
  return Curry._1(t._0, input);
}

function run(t, inputString) {
  return runOnInput(t, {
              position: {
                prevLines: /* [] */0,
                index: 0,
                lineStart: 0,
                line: 1,
                col: 1
              },
              input: inputString
            });
}

function bind(t, fn) {
  return /* Parser */{
          _0: (function (input) {
              var msg = runOnInput(t, input);
              if (msg.TAG !== /* Ok */0) {
                return {
                        TAG: /* Error */1,
                        _0: msg._0
                      };
              }
              var match = msg._0;
              return runOnInput(Curry._1(fn, match[0]), match[1]);
            })
        };
}

function $$return(x) {
  return /* Parser */{
          _0: (function (input) {
              return {
                      TAG: /* Ok */0,
                      _0: [
                        x,
                        input
                      ]
                    };
            })
        };
}

function map(t, fn) {
  return bind(t, (function (x) {
                return $$return(Curry._1(fn, x));
              }));
}

function andThen(p1, p2) {
  return bind(p1, (function (res1) {
                return bind(p2, (function (res2) {
                              return $$return([
                                          res1,
                                          res2
                                        ]);
                            }));
              }));
}

function satisfy(predicate) {
  return /* Parser */{
          _0: (function (input) {
              var $$char = getChar(input);
              if ($$char !== undefined) {
                if (Curry._1(predicate, $$char)) {
                  return {
                          TAG: /* Ok */0,
                          _0: [
                            $$char,
                            next$1(input)
                          ]
                        };
                } else {
                  return {
                          TAG: /* Error */1,
                          _0: {
                            message: "Unexpected \"" + Char.escaped($$char) + "\".\n",
                            state: input
                          }
                        };
                }
              } else {
                return {
                        TAG: /* Error */1,
                        _0: {
                          message: "No more input",
                          state: input
                        }
                      };
              }
            })
        };
}

function $$char(expected) {
  return satisfy(function (param) {
              return Char.equal(expected, param);
            });
}

function orElse(parser1, parser2) {
  return /* Parser */{
          _0: (function (input) {
              var result = runOnInput(parser1, input);
              if (result.TAG === /* Ok */0) {
                return result;
              } else {
                return runOnInput(parser2, input);
              }
            })
        };
}

function choice(parsers) {
  return Belt_Array.reduce(parsers, /* Parser */{
              _0: (function (input) {
                  return {
                          TAG: /* Error */1,
                          _0: {
                            message: "Initial parser",
                            state: input
                          }
                        };
                })
            }, orElse);
}

function anyOf(chars) {
  return choice(Belt_Array.map(chars, $$char));
}

function apply(parserA, parserB) {
  return bind(parserB, (function (f) {
                return bind(parserA, (function (x) {
                              return $$return(Curry._1(f, x));
                            }));
              }));
}

function lift2(parserA, fn, parserB) {
  return apply(parserB, apply(parserA, $$return(fn)));
}

function sequence(parsers) {
  if (parsers) {
    return lift2(parsers.hd, List.cons, sequence(parsers.tl));
  } else {
    return /* Parser */{
            _0: (function (input) {
                return {
                        TAG: /* Ok */0,
                        _0: [
                          /* [] */0,
                          input
                        ]
                      };
              })
          };
  }
}

function zeroOrMore(parser, input) {
  var match = runOnInput(parser, input);
  if (match.TAG !== /* Ok */0) {
    return [
            /* [] */0,
            input
          ];
  }
  var match$1 = match._0;
  var match$2 = zeroOrMore(parser, match$1[1]);
  return [
          {
            hd: match$1[0],
            tl: match$2[0]
          },
          match$2[1]
        ];
}

function many(parser) {
  return /* Parser */{
          _0: (function (input) {
              return {
                      TAG: /* Ok */0,
                      _0: zeroOrMore(parser, input)
                    };
            })
        };
}

function atLeastOne(parser) {
  return bind(parser, (function (head) {
                return bind(many(parser), (function (tail) {
                              return $$return({
                                          hd: head,
                                          tl: tail
                                        });
                            }));
              }));
}

function keepLeft(parserA, parserB) {
  return map(andThen(parserA, parserB), (function (prim) {
                return prim[0];
              }));
}

function keepRight(parserA, parserB) {
  return map(andThen(parserA, parserB), (function (prim) {
                return prim[1];
              }));
}

function between(parserA, parserB, parserC) {
  return keepLeft(keepRight(parserB, parserA), parserC);
}

function separatedBy1(parser, separator) {
  var separators = keepRight(separator, parser);
  return map(andThen(parser, many(separators)), (function (param) {
                return {
                        hd: param[0],
                        tl: param[1]
                      };
              }));
}

function separatedBy(parser, separator) {
  return orElse(separatedBy1(parser, separator), /* Parser */{
              _0: (function (input) {
                  return {
                          TAG: /* Ok */0,
                          _0: [
                            /* [] */0,
                            input
                          ]
                        };
                })
            });
}

function string(x) {
  return map(map(map(sequence(Belt_List.fromArray(Belt_Array.map(Belt_Array.map(x.split(""), (function (__x) {
                                        return Caml_string.get(__x, 0);
                                      })), $$char))), (function (__x) {
                        return Belt_List.map(__x, Char.escaped);
                      })), Belt_List.toArray), (function (param) {
                return param.join("");
              }));
}

function makeForwardRef(param) {
  var parser = /* Parser */{
    _0: (function (param) {
        return Pervasives.failwith("Not implemented");
      })
  };
  var parserRef = {
    contents: parser
  };
  return [
          /* Parser */{
            _0: (function (input) {
                return runOnInput(parserRef.contents, input);
              })
          },
          parserRef
        ];
}

function makeRecursive(fn) {
  var match = makeForwardRef(undefined);
  var parserRef = match[1];
  parserRef.contents = Curry._1(fn, match[0]);
  return parserRef.contents;
}

function optional(parser) {
  var some = map(parser, (function (x) {
          return Caml_option.some(x);
        }));
  var none = /* Parser */{
    _0: (function (input) {
        return {
                TAG: /* Ok */0,
                _0: [
                  undefined,
                  input
                ]
              };
      })
  };
  return orElse(some, none);
}

exports.Position = Position;
exports.State = State;
exports.$$Error = $$Error;
exports.runOnInput = runOnInput;
exports.run = run;
exports.bind = bind;
exports.$$return = $$return;
exports.map = map;
exports.andThen = andThen;
exports.satisfy = satisfy;
exports.$$char = $$char;
exports.orElse = orElse;
exports.choice = choice;
exports.anyOf = anyOf;
exports.apply = apply;
exports.lift2 = lift2;
exports.sequence = sequence;
exports.zeroOrMore = zeroOrMore;
exports.many = many;
exports.atLeastOne = atLeastOne;
exports.keepLeft = keepLeft;
exports.keepRight = keepRight;
exports.between = between;
exports.separatedBy1 = separatedBy1;
exports.separatedBy = separatedBy;
exports.string = string;
exports.makeForwardRef = makeForwardRef;
exports.makeRecursive = makeRecursive;
exports.optional = optional;
/* No side effect */
