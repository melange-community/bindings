<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Match-Blossom (Blossom.Match-Blossom)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../">Up</a> – <a href="../">Blossom</a> &#x00BB; Match-Blossom</nav><h1>Module <code>Match-Blossom</code></h1><p><b>ReScript-Blossom</b> is a <a href="https://rescript-lang.org/">ReScript</a> implementation of the famous <a href="https://en.wikipedia.org/wiki/Blossom_algorithm">blossom algorithm</a>. It finds a maximum matching of vertices on general, undirected, weighted graphs.</p><p><a href="https://github.com/johnridesabike/rescript-blossom">Browse the source.</a></p><nav class="toc"><ul><li><a href="#installation">Installation</a></li><li><a href="#how-it-works">How it works</a></li><li><a href="#usage">Usage</a><ul><li><a href="#using-the-output">Using the output</a></li><li><a href="#maximum-cardinality">Maximum cardinality</a></li><li><a href="#your-own-types">Your own types</a></li></ul></li><li><a href="#beta-warning">Beta warning</a></li><li><a href="#interface">Interface</a><ul><li><a href="#types">Types</a></li><li><a href="#functions">Functions</a></li><li><a href="#prepackaged-modules">Prepackaged modules</a></li><li><a href="#creating-comparables">Creating comparables</a></li></ul></li><li><a href="#changelog">Changelog</a></li><li><a href="#similar-packages">Similar packages</a><ul><li><a href="#javascript">JavaScript</a></li><li><a href="#python">Python</a></li></ul></li><li><a href="#credits">Credits</a></li><li><a href="#license">License</a></li></ul></nav></header><section><header><h2 id="installation"><a href="#installation" class="anchor"></a>Installation</h2><p>You can add ReScript-Blossom to your project by running:</p><pre><code class="ml">npm install rescript-blossom</code></pre><p>You will need to edit your project's <code>bsconfig.json</code> file and list ReScript-Blossom in the <code>bs-dependencies</code>.</p><pre><code class="ml">{
  &quot;bs-dependencies&quot;: [
    &quot;rescript-blossom&quot;
  ]
}</code></pre><p>You can now access this module as <code>Blossom.Match</code>.</p></header></section><section><header><h2 id="how-it-works"><a href="#how-it-works" class="anchor"></a>How it works</h2><p>Matching along an undirected, weighted graph is notoriously difficult. The blossom algorithm does the heavy lifting for us in O(n³) time. Let's look at a simple example.</p><p>Suppose you have a list of chess players, <code>[Mary, Joseph, Matthew, Mark, Luke,
John, Peter, Andrew, James, Philip]</code>, and you want to pair them to compete in a tournament round.</p><p>Your first step is to list all of your possible pairings.</p><pre><code class="ml">let graph = list{
  (Mary, Joseph),
  (Mary, Matthew),
  (Joseph, Matthew),
  (Joseph, Mark),
  (Matthew, Luke),
  (Mark, Luke),
  (Mary, Andrew),
  (Luke, Peter),
  (Peter, John),
  (Andrew, Philip),
  (Mark, James)
}</code></pre><p>(Typically your list will be much longer, but this is just an illustration.)</p><p>Next, you will need to determine the <i>weight</i> of each pairing. This is a floating-point number that indicates how desirable that pairing is.</p><pre><code class="ml">let graph = list{
  (Mary, Joseph, 40.),
  (Mary, Matthew, 40.),
  (Joseph, Matthew, 60.),
  (Joseph, Mark, 55.),
  (Matthew, Luke, 55.),
  (Mark, Luke, 50.),
  (Mary, Andrew, 15.),
  (Luke, Peter, 30.),
  (Peter, John, 10.),
  (Andrew, Philip, 10.),
  (Mark, James, 10.)
}</code></pre><p>In graph theory, each of the people is a &quot;vertex,&quot; and each pair of people is an &quot;edge.&quot; We can visualize it in 2D space.</p><pre>
  Andrew ---10--- Philip                  Peter
    |                                    /     \
   15                                  30       10
    |                                  /         \
   Mary ---40--- Matthew ---55---- Luke         John
      \          /                  /
       40      60                 50
        \      /                  /
         Joseph ------ 55 ----- Mark ----30---- James
</pre><p>Note that we couldn't use the edge with the highest weight because choosing it would leave another vertex with no connections. We also have to use the two edges with the lowest weights because we're committed to matching as many vertices as possible.</p><p>As you can see, finding the <i>maximum</i> weighted matching is often unintuitive. Imagine how much more difficult this becomes when you have dozens, or hundreds, of people, and we could potentially match every person with anyone else!</p></header></section><section><header><h2 id="usage"><a href="#usage" class="anchor"></a>Usage</h2><p>Your data can be any type, but suppose you're using <code>string</code> vertices.</p><pre><code class="ml">let graph = list{
  (&quot;Mary&quot;, &quot;Joseph&quot;, 40.),
  (&quot;Mary&quot;, &quot;Michael&quot;, 40.),
  (&quot;Joseph&quot;, &quot;Michael&quot;, 60.),
  (&quot;Joseph&quot;, &quot;Gabriel&quot;, 55.),
  (&quot;Michael&quot;, &quot;Raphael&quot;, 55.),
  (&quot;Gabriel&quot;, &quot;Raphael&quot;, 50.),
  (&quot;Mary&quot;, &quot;Paul&quot;, 15.),
  (&quot;Raphael&quot;, &quot;Peter&quot;, 30.),
  (&quot;Peter&quot;, &quot;John&quot;, 10.),
  (&quot;Paul&quot;, &quot;James&quot;, 10.),
  (&quot;Gabriel&quot;, &quot;Andrew&quot;, 30.),
}</code></pre><p>You can match them with <a href="String#val-make"><code>String.make</code></a>.</p><pre><code class="ml">let result = Blossom.Match.String.make(graph)</code></pre><p>You can also use <a href="Int#val-make"><code>Int.make</code></a> for integer vertices.</p></header><section><header><h3 id="using-the-output"><a href="#using-the-output" class="anchor"></a>Using the output</h3><p>The algorithm returns a bi-directional map of each vertex to its mate vertex.</p><pre><code class="ml">Blossom.Match.get(result, &quot;Mary&quot;) == Some(&quot;Joseph&quot;)
Blossom.Match.get(result, &quot;Joseph&quot;) == Some(&quot;Mary&quot;)</code></pre><p>It's powered by <code>Belt.Map</code> under the hood. You can convert it to a proper <code>Belt.Map</code> with <a href="#val-toMap"><code>toMap</code></a>, or a list with <a href="#val-toList"><code>toList</code></a>. <i>The output of these will have each pairing twice.</i> This is because it treats each order (<code>(a, b)</code> vs <code>(b, a)</code>) separately. In practice, this is useful so you can use <code>Belt.Map.get</code> or <code>Belt.List.getAssoc</code> to get any vertex's mate.</p></header></section><section><header><h3 id="maximum-cardinality"><a href="#maximum-cardinality" class="anchor"></a>Maximum cardinality</h3><p>The <a href="#val-make"><code>make</code></a> functions accepts one optional parameter, <code>cardinality</code>, which can be the value <code>#Max</code>. This enables &quot;maximum cardinality&quot; matching, where the algorithm will only accept solutions that use as many edges as possible, even extremely undesirable ones (such as ones with negative weights).</p><pre><code class="ml">let graph = list{
  (1, 2, 2.),
  (1, 3, (-2.)),
  (2, 3, 1.),
  (2, 4, (-1.)),
  (3, 4, (-6.)),
}

let result = Blossom.Match.Int.make(graph)
/* result: (1, 2) */

let result = Blossom.Match.Int.make(~cardinality=#Max, graph)
/* result: (1, 3), (2, 4) */</code></pre></header></section><section><header><h3 id="your-own-types"><a href="#your-own-types" class="anchor"></a>Your own types</h3><p>To use your own type, first you need a module that conforms to the <a href="#type-comparable"><code>comparable</code></a> signature. (If you've used the <code>Belt.Id</code> module before, this should be familiar.)</p><pre><code class="ml">module MyType: {
  type t
  let cmp: (t, t) =&gt; int
} = {
  /* implementation goes here */
}

module MyTypeCmp = Blossom.Match.MakeComparable(MyType)</code></pre><p>Now you can call <a href="#val-make"><code>make</code></a> with the module and your list of edges.</p><pre><code class="ml">let result = Blossom.Match.make(~id=module(MyTypeCmp), graph)</code></pre><p>You can also reuse an existing Belt <code>Comparable</code> module by using <a href="#val-unsafeComparableFromBelt"><code>unsafeComparableFromBelt</code></a>. The use case for that is when you need the <code>identity</code> type shared between modules.</p></header></section></section><section><header><h2 id="beta-warning"><a href="#beta-warning" class="anchor"></a>Beta warning</h2><p>This algorithm passes all of the tests from similar implementations, but hasn't seen much real-world use. There may still be failure states that have not been discovered yet. The specific dangers are <code>Failure</code> exceptions, infinite loops, or missing pairings. These should never happen, but, if they do, please <a href="https://github.com/johnridesabike/rescript-blossom/issues">file an issue</a> with information about your graph.</p></header></section><section><header><h2 id="interface"><a href="#interface" class="anchor"></a>Interface</h2></header><section><header><h3 id="types"><a href="#types" class="anchor"></a>Types</h3></header><div class="spec module" id="module-Internal"><a href="#module-Internal" class="anchor"></a><code><span class="keyword">module</span> <a href="Internal">Internal</a>: { ... };</code></div><div class="spec module-type" id="module-type-Comparable"><a href="#module-type-Comparable" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Comparable">Comparable</a> = { ... };</code></div><dl><dt class="spec type" id="type-comparable"><a href="#type-comparable" class="anchor"></a><code><span class="keyword">type</span> <span class="keyword">nonrec</span> comparable('vertex, 'id)</code><code> = (<span class="keyword">module</span> <a href="module-type-Comparable">Comparable</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-Comparable#type-identity">identity</a> = <span class="type-var">'id</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-Comparable#type-t">t</a> = <span class="type-var">'vertex</span>)</code>;</dt><dd><p>A module of functions with a unique identity type. It is analogous to the type <code>Belt.Id.comparable</code>. Create one with the <a href="#val-comparable"><code>comparable</code></a> function or the <a href="MakeComparable"><code>MakeComparable</code></a> functor. Or create one with an existing <code>Belt.Id.comparable</code> module with <a href="#val-unsafeComparableFromBelt"><code>unsafeComparableFromBelt</code></a>.</p></dd></dl><dl><dt class="spec type" id="type-cardinality"><a href="#type-cardinality" class="anchor"></a><code><span class="keyword">type</span> <span class="keyword">nonrec</span> cardinality</code> = <code>[ </code><table class="variant"><tr id="type-cardinality.Max" class="anchored"><td class="def constructor"><a href="#type-cardinality.Max" class="anchor"></a><code>| </code><code>`Max</code></td></tr><tr id="type-cardinality.NotMax" class="anchored"><td class="def constructor"><a href="#type-cardinality.NotMax" class="anchor"></a><code>| </code><code>`NotMax</code></td></tr></table><code> ]</code>;</dt><dd><p>Represents whether or not the algorithm should <i>only</i> accept maximum-cardinality solutions.</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span class="keyword">nonrec</span> t('vertex, 'id)</code>;</dt><dd><p>A bi-directional, read-only mapping of each vertex to its mate vertex.</p></dd></dl></section><section><header><h3 id="functions"><a href="#functions" class="anchor"></a>Functions</h3></header><dl><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">let</span> make: ?&#8288;cardinality:<a href="#type-cardinality">cardinality</a> <span>=&gt;</span> list((<span class="type-var">'vertex</span>, <span class="type-var">'vertex</span>, float)) <span>=&gt;</span> id:<a href="#type-comparable">comparable</a>(<span class="type-var">'vertex</span>, <span class="type-var">'id</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'vertex</span>, <span class="type-var">'id</span>);</code></dt><dd><p>Computes a maximum-weighted matching on a general undirected weighted graph. This function takes time O(n³). See <a href="#usage"><span>Usage</span></a> for examples of its use.</p><p>Accepts a list of tuples <code>(i, j, w)</code>, each describing an undirected edge between vertex <code>i</code> and vertex <code>j</code> with weight <code>w</code>. There is at most one edge between any two vertices, and no vertex has an edge to itself. Duplicate edges are ignored.</p><p><a href="Int#val-make"><code>Int.make</code></a> and <a href="String#val-make"><code>String.make</code></a> are prepackaged versions of this function for <code>int</code> and <code>string</code> vertices, respectively.</p><dl><dt>parameter cardinality</dt><dd><p>When set to <code>#Max</code>, only maximum-cardinality matchings are considered as solutions. <code>#NotMax</code> is the default.</p></dd></dl><dl><dt>parameter id</dt><dd><p>A first-class module created by <a href="#val-comparable"><code>comparable</code></a> or <a href="MakeComparable"><code>MakeComparable</code></a>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-get"><a href="#val-get" class="anchor"></a><code><span class="keyword">let</span> get: <a href="#type-t">t</a>(<span class="type-var">'vertex</span>, <span class="type-var">'id</span>) <span>=&gt;</span> <span class="type-var">'vertex</span> <span>=&gt;</span> option(<span class="type-var">'vertex</span>);</code></dt><dd><p>Returns <code>Some(mate)</code> for a mated vertex, or <code>None</code> if none exists.</p><pre><code class="ml">Blossom.Match.get(result, &quot;Mary&quot;) == Some(&quot;Joseph&quot;)</code></pre></dd></dl><dl><dt class="spec value" id="val-reduce"><a href="#val-reduce" class="anchor"></a><code><span class="keyword">let</span> reduce: <a href="#type-t">t</a>(<span class="type-var">'vertex</span>, <span class="type-var">'id</span>) <span>=&gt;</span> init:<span class="type-var">'acc</span> <span>=&gt;</span> f:(<span class="type-var">'acc</span> <span>=&gt;</span> <span class="type-var">'vertex</span> <span>=&gt;</span> <span class="type-var">'vertex</span> <span>=&gt;</span> <span class="type-var">'acc</span>) <span>=&gt;</span> <span class="type-var">'acc</span>;</code></dt><dd><p>Reduces over the pairs of vertex mates. Each pair is used twice, once in each order.</p><pre><code class="ml">let list =
  Blossom.Match.reduce(
    result,
    ~init=list{},
    ~f=(acc, v1, v2) =&gt; list{(v1, v2), ...acc}
  )</code></pre></dd></dl><dl><dt class="spec value" id="val-reduceU"><a href="#val-reduceU" class="anchor"></a><code><span class="keyword">let</span> reduceU: <a href="#type-t">t</a>(<span class="type-var">'vertex</span>, <span class="type-var">'id</span>) <span>=&gt;</span> init:<span class="type-var">'acc</span> <span>=&gt;</span> f:Js.Fn.arity3((<span class="type-var">'acc</span> <span>=&gt;</span> <span class="type-var">'vertex</span> <span>=&gt;</span> <span class="type-var">'vertex</span> <span>=&gt;</span> <span class="type-var">'acc</span>)) <span>=&gt;</span> <span class="type-var">'acc</span>;</code></dt><dd><p>Reduces over the pairs of vertex mates. Each pair is used twice, once in each order.</p><p>Takes an uncurried <code>f</code> function.</p><pre><code class="ml">let list =
  Blossom.Match.reduce(
    result, 
    ~init=list{}, 
    ~f=(. acc, v1, v2) =&gt; list{(v1, v2), ...acc}
  )</code></pre></dd></dl><dl><dt class="spec value" id="val-forEach"><a href="#val-forEach" class="anchor"></a><code><span class="keyword">let</span> forEach: <a href="#type-t">t</a>(<span class="type-var">'vertex</span>, <span class="type-var">'id</span>) <span>=&gt;</span> f:(<span class="type-var">'vertex</span> <span>=&gt;</span> <span class="type-var">'vertex</span> <span>=&gt;</span> unit) <span>=&gt;</span> unit;</code></dt><dd><p>Iterates over the pairs of vertex mates. Each pair is used twice, once in each order.</p><pre><code class="ml">Blossom.Match.forEach(result, ~f=(v1, v2) =&gt; Js.log2(v1, v2))</code></pre></dd></dl><dl><dt class="spec value" id="val-forEachU"><a href="#val-forEachU" class="anchor"></a><code><span class="keyword">let</span> forEachU: <a href="#type-t">t</a>(<span class="type-var">'vertex</span>, <span class="type-var">'id</span>) <span>=&gt;</span> f:Js.Fn.arity2((<span class="type-var">'vertex</span> <span>=&gt;</span> <span class="type-var">'vertex</span> <span>=&gt;</span> unit)) <span>=&gt;</span> unit;</code></dt><dd><p>Iterates over the pairs of vertex mates. Each pair is used twice, once in order.</p><p>Takes an uncurried <code>f</code> function.</p><pre><code class="ml">Blossom.Match.forEachU(result, ~f=(. v1, v2) =&gt; Js.log2(v1, v2))</code></pre></dd></dl><dl><dt class="spec value" id="val-toMap"><a href="#val-toMap" class="anchor"></a><code><span class="keyword">let</span> toMap: <a href="#type-t">t</a>(<span class="type-var">'vertex</span>, <span class="type-var">'id</span>) <span>=&gt;</span> Belt.Map.t(<span class="type-var">'vertex</span>, <span class="type-var">'vertex</span>, <span class="type-var">'id</span>);</code></dt><dd><p>Returns a <code>Belt.Map.t</code> where each key is a vertex and each value is its mate.</p><pre><code class="ml">let map = Blossom.Match.toMap(result)
Belt.Map.get(map, &quot;Mary&quot;) == Some(&quot;Joseph&quot;)</code></pre></dd></dl><dl><dt class="spec value" id="val-toList"><a href="#val-toList" class="anchor"></a><code><span class="keyword">let</span> toList: <a href="#type-t">t</a>(<span class="type-var">'vertex</span>, <span class="type-var">'id</span>) <span>=&gt;</span> list((<span class="type-var">'vertex</span>, <span class="type-var">'vertex</span>));</code></dt><dd><p>Returns a list of tuples for each pair of vertex mates. Each pair is used twice, once in each order.</p><pre><code class="ml">Blossom.Match.toList(result) == list{
  (&quot;Raphael&quot;, &quot;Michael&quot;),
  (&quot;Peter&quot;, &quot;John&quot;),
  (&quot;Paul&quot;, &quot;James&quot;),
  (&quot;Michael&quot;, &quot;Raphael&quot;),
  (&quot;Mary&quot;, &quot;Joseph&quot;),
  (&quot;Joseph&quot;, &quot;Mary&quot;),
  (&quot;John&quot;, &quot;Peter&quot;),
  (&quot;James&quot;, &quot;Paul&quot;),
  (&quot;Gabriel&quot;, &quot;Andrew&quot;),
  (&quot;Andrew&quot;, &quot;Gabriel&quot;),
}</code></pre></dd></dl><dl><dt class="spec value" id="val-isEmpty"><a href="#val-isEmpty" class="anchor"></a><code><span class="keyword">let</span> isEmpty: <a href="#type-t">t</a>(<span class="type-var">'vertex</span>, <span class="type-var">'id</span>) <span>=&gt;</span> bool;</code></dt><dd><p>Returns <code>true</code> if there are no mates, <code>false</code> otherwise.</p><pre><code class="ml">Blossom.Match.isEmpty(result) == false</code></pre></dd></dl><dl><dt class="spec value" id="val-has"><a href="#val-has" class="anchor"></a><code><span class="keyword">let</span> has: <a href="#type-t">t</a>(<span class="type-var">'vertex</span>, <span class="type-var">'id</span>) <span>=&gt;</span> <span class="type-var">'vertex</span> <span>=&gt;</span> bool;</code></dt><dd><p>Returns <code>true</code> if the vertex has a mate, <code>false</code> otherwise.</p><pre><code class="ml">Blossom.Match.has(result, &quot;Mary&quot;) == true</code></pre></dd></dl></section><section><header><h3 id="prepackaged-modules"><a href="#prepackaged-modules" class="anchor"></a>Prepackaged modules</h3></header><dl><dt class="spec module" id="module-Int"><a href="#module-Int" class="anchor"></a><code><span class="keyword">module</span> <a href="Int">Int</a>: { ... };</code></dt><dd><p>Prepackaged module for building graphs with <code>int</code> vertices.</p></dd></dl><dl><dt class="spec module" id="module-String"><a href="#module-String" class="anchor"></a><code><span class="keyword">module</span> <a href="String">String</a>: { ... };</code></dt><dd><p>Prepackaged module for building graphs with <code>string</code> vertices.</p></dd></dl></section><section><header><h3 id="creating-comparables"><a href="#creating-comparables" class="anchor"></a>Creating comparables</h3></header><dl><dt class="spec value" id="val-unsafeComparableFromBelt"><a href="#val-unsafeComparableFromBelt" class="anchor"></a><code><span class="keyword">let</span> unsafeComparableFromBelt: id:Belt.Id.comparable(<span class="type-var">'vertex</span>, <span class="type-var">'id</span>) <span>=&gt;</span> cmp:(<span class="type-var">'vertex</span> <span>=&gt;</span> <span class="type-var">'vertex</span> <span>=&gt;</span> int) <span>=&gt;</span> <a href="#type-comparable">comparable</a>(<span class="type-var">'vertex</span>, <span class="type-var">'id</span>);</code></dt><dd><p>Turns a <code>Belt.Id.comparable</code> module into <a href="#type-comparable"><code>comparable</code></a>.</p><p>This is unsafe because the compiler can't guarantee the <code>cmp</code> value will be correct.</p><pre><code class="ml">module MyTypeCmp = Belt.Id.MakeComparable(MyType)
let blossomCmp =
  Blossom.Match.unsafeComparableFromBelt(
    ~id=module(MyTypeCmp),
    ~cmp=MyType.cmp
  )</code></pre></dd></dl><dl><dt class="spec value" id="val-unsafeComparableFromBeltU"><a href="#val-unsafeComparableFromBeltU" class="anchor"></a><code><span class="keyword">let</span> unsafeComparableFromBeltU: id:Belt.Id.comparable(<span class="type-var">'vertex</span>, <span class="type-var">'id</span>) <span>=&gt;</span> cmp:Js.Fn.arity2((<span class="type-var">'vertex</span> <span>=&gt;</span> <span class="type-var">'vertex</span> <span>=&gt;</span> int)) <span>=&gt;</span> <a href="#type-comparable">comparable</a>(<span class="type-var">'vertex</span>, <span class="type-var">'id</span>);</code></dt><dd><p>Turns a <code>Belt.Id.comparable</code> module into a <a href="#type-comparable"><code>comparable</code></a> with an uncurried <code>cmp</code> function.</p><p>This is unsafe because the compiler can't guarantee the <code>cmp</code> value will be correct.</p></dd></dl><dl><dt class="spec module" id="module-MakeComparable"><a href="#module-MakeComparable" class="anchor"></a><code><span class="keyword">module</span> <a href="MakeComparable">MakeComparable</a>:  (<a href="MakeComparable/argument-1-M">M</a>: { ... }) <span>=&gt;</span> <a href="#module-type-Comparable">Comparable</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="MakeComparable#type-t">t</a> = <a href="MakeComparable/argument-1-M#type-t">M.t</a>;</code></dt><dd><p>Creates a <a href="#type-comparable"><code>comparable</code></a>.</p></dd></dl><dl><dt class="spec module" id="module-MakeComparableU"><a href="#module-MakeComparableU" class="anchor"></a><code><span class="keyword">module</span> <a href="MakeComparableU">MakeComparableU</a>:  (<a href="MakeComparableU/argument-1-M">M</a>: { ... }) <span>=&gt;</span> <a href="#module-type-Comparable">Comparable</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="MakeComparableU#type-t">t</a> = <a href="MakeComparableU/argument-1-M#type-t">M.t</a>;</code></dt><dd><p>Creates a <a href="#type-comparable"><code>comparable</code></a> with an uncurried <code>cmp</code> function.</p></dd></dl><dl><dt class="spec value" id="val-comparable"><a href="#val-comparable" class="anchor"></a><code><span class="keyword">let</span> comparable: (<span class="type-var">'vertex</span> <span>=&gt;</span> <span class="type-var">'vertex</span> <span>=&gt;</span> int) <span>=&gt;</span> (<span class="keyword">module</span> <a href="module-type-Comparable">Comparable</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-Comparable#type-t">t</a> = <span class="type-var">'vertex</span>);</code></dt><dd><p>Creates a <a href="#type-comparable"><code>comparable</code></a>.</p><pre><code class="ml">module IntCmp = unpack(Match.comparable(compare: (int, int) =&gt; int))</code></pre></dd></dl><dl><dt class="spec value" id="val-comparableU"><a href="#val-comparableU" class="anchor"></a><code><span class="keyword">let</span> comparableU: Js.Fn.arity2((<span class="type-var">'vertex</span> <span>=&gt;</span> <span class="type-var">'vertex</span> <span>=&gt;</span> int)) <span>=&gt;</span> (<span class="keyword">module</span> <a href="module-type-Comparable">Comparable</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-Comparable#type-t">t</a> = <span class="type-var">'vertex</span>);</code></dt><dd><p>Creates a <a href="#type-comparable"><code>comparable</code></a> with an uncurried <code>cmp</code> function.</p></dd></dl><dl><dt class="spec value" id="val-comparableToBelt"><a href="#val-comparableToBelt" class="anchor"></a><code><span class="keyword">let</span> comparableToBelt: <a href="#type-comparable">comparable</a>(<span class="type-var">'vertex</span>, <span class="type-var">'id</span>) <span>=&gt;</span> Belt.Id.comparable(<span class="type-var">'vertex</span>, <span class="type-var">'id</span>);</code></dt><dd><p>Turns a <a href="#type-comparable"><code>comparable</code></a> into a <code>Belt.Id.comparable</code>.</p></dd></dl></section></section><section><header><h2 id="changelog"><a href="#changelog" class="anchor"></a>Changelog</h2><p><a href="https://github.com/johnridesabike/rescript-blossom/blob/master/CHANGELOG.md">See the CHANGELOG.md file.</a></p></header></section><section><header><h2 id="similar-packages"><a href="#similar-packages" class="anchor"></a>Similar packages</h2></header><section><header><h3 id="javascript"><a href="#javascript" class="anchor"></a>JavaScript</h3><p>The <a href="https://www.npmjs.com/package/edmonds-blossom">edmonds-blossom</a> package uses the same algorithm. It should return the exact same pairings that this version does, but it doesn't have the flexibility of using different types.</p></header></section><section><header><h3 id="python"><a href="#python" class="anchor"></a>Python</h3><p><a href="http://jorisvr.nl/article/maximum-matching">Joris van Rantwijk's Python implementation</a> was the basis of both the JavaScript version and this ReScript version.</p></header></section></section><section><header><h2 id="credits"><a href="#credits" class="anchor"></a>Credits</h2><ul><li><a href="https://johnridesa.bike/">John</a> - idea and initial work.</li><li><a href="http://jorisvr.nl/">Joris van Rantwijk</a> - his Python code was an invaluable reference.</li></ul><p>I can't take any credit for the algorithm itself. It exists thanks to many people much smarter than me.</p></header></section><section><header><h2 id="license"><a href="#license" class="anchor"></a>License</h2><p>Copyright (c) 2021 John Jackson</p><p>This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.</p></header></section></div></body></html>