/**
`t<'a>` represents a lazy sequence whose items are only computed upon demand.
*/
type t<'a>

exception InvalidArgument(string)

/**
`empty` is a sequence with nothing in it.
*/
let empty: t<'a>

/**
`once(value)` is a sequence of a single item.
*/
let once: 'a => t<'a>

/**
`onceWith(f)` is a sequence composed of a single item, constructed lazily by `f`
*/
let onceWith: (unit => 'a) => t<'a>

/**
`unfold(seed, f)` creates a sequence that contains the elements generated by a
computation. The function `f` is first passed `seed` and then is repeatedly
called to build the sequence. When `f` returns a tuple of `Some(item, seed)`,
`item` is added to the sequence, and `seed` is fed into the next computation.
When `f` returns `None`, the computation is complete.

## Examples

```rescript
Seq.unfold(1, i => i < 100 ? Some(i, i * 2) : None) // [1, 2, 4, 8, 16, 32, 64]
```
*/
let unfold: ('seed, 'seed => option<('a, 'seed)>) => t<'a>

/**
`init(count, f)` initializes a sequence based on a `count` and a function `f`
that is provided index values from 0 up to `count-1`.

## Examples

```rescript
Seq.init(3, inx => inx * 2) // [0, 2, 4]
```
*/
let init: (int, int => 'a) => t<'a>

/**
`replicate(item, count)` is the sequence of `item` repeated exacly `count` times.
*/
let replicate: ('a, int) => t<'a>

/**
`replicateWith(f, count)` is the sequence of length `count` where `f()` is called
to generate each item.
*/
let replicateWith: (unit => 'a, int) => t<'a>

/**
`forever(item)` is the sequence of `item` repeated forever.
*/
let forever: 'a => t<'a>

/**
`foreverWith(f)` creates an infinite sequence comprised of calling the function
`f` each time an item is generated.
*/
let foreverWith: (unit => 'a) => t<'a>

/**
`iterate(seed, f)` creates an infinite sequence starting with `seed` and
repeatedly calling function `f` on it.
*/
let iterate: ('a, 'a => 'a) => t<'a>

/**
`cycle` is the sequence that consists of an infinite number of repetitions of
the input sequence. If the original sequence is empty, the resulting sequence
will also be empty.

**Note:** The process for generating items is cycled, rather than cycling the
values produced. For example, if the original sequence is based on a function
that generates random numbers, then when the sequence repeats new random numbers
will be produced. If this is not the desired behavior consider using `cache`
before calling `cycle`.
*/
let cycle: t<'a> => t<'a>

/**
`range(start, end)` is the sequence integers from `start` to `end` (inclusive).
If `start` is greater than `end` the sequence of numbers descends.
*/
let range: (int, int) => t<int>

/**
`rangeMap(start, end, mapper)` is the sequence from that results from calling
`mapper` on each integer from `start` to `end` inclusive. If `start` is
greater than `end` the numbers descend.
*/
let rangeMap: (int, int, int => 'a) => t<'a>

/**
`fromArray(start, end)` generates a sequence from an array. `start` and `end`
indexes can optionally be provided.
*/
let fromArray: (~start: int=?, ~end: int=?, array<'a>) => t<'a>

/**
`fromList` generates a sequence from a list.
*/
let fromList: list<'a> => t<'a>

/**
`cons(head, tail)` constructs the sequence that begins with the element `head`
followed by the sequence `tail`.

## Examples

```rescript
cons(1, [2, 3, 4]) // [1, 2, 3, 4]
cons(1, []) // [1]
```
*/
let cons: ('a, t<'a>) => t<'a>

/**
`prepend(yy, xx)` is all items in `xx`, the second argument, followed by all
items in `yy`, the first argument. See `concat` for the same behavior but the
arguments reversed.
*/
let prepend: (t<'a>, t<'a>) => t<'a>

/**
`concat(xx, yy)` is all items in `xx` followed by all items in `yy`. This is a
synonym for `append`. See `prepend` for the same behavior but the arguments
reversed.
*/
let concat: (t<'a>, t<'a>) => t<'a>

/**
`append(xx, yy)` is all items in `xx` followed by all items in `yy`. This is a
synonym for `concat`. See `prepend` for the same behavior but the arguments
reversed.
*/
let append: (t<'a>, t<'a>) => t<'a>

/**
`flatten` creates a sequence by concatenating every item in each sub-sequence.
Analogous to the JavaScript `Array.flat` with a depth of 1.
*/
let flatten: t<t<'a>> => t<'a>

/**
`flatMap(source, mapper)` creates a sequence by calling the `mapper` callback on
each item in `source` and then concatenating every item produced. Also known as
`bind` or `selectMany`. Analogous to `Array.flatMap` in JavaScript.
*/
let flatMap: (t<'a>, 'a => t<'b>) => t<'b>

/**
`map(source, mapper)` is the sequence that results by calling the `mapper`
callback on each item in `source`.
*/
let map: (t<'a>, 'a => 'b) => t<'b>

/**
`map(source, mapper)` is the sequence that results by calling the `mapper`
callback on each item in `source`. The callback receives the zero-based index of
each item.
*/
let mapi: (t<'a>, ('a, int) => 'b) => t<'b>

/**
`indexed` builds a new sequence whose elements are the corresponding items of
the input sequence paired with the zero-based integer index of each item.
*/
let indexed: t<'a> => t<('a, int)>

/**
`filter` builds a new sequence containing only the items for which the given
predicate returns "true". Similar to `Array.filter` in JavaScript.
*/
let filter: (t<'a>, 'a => bool) => t<'a>

/**
`filteri` builds a new sequence containing only the items for which the given
predicate returns "true". The callback receives the zero-based index of each
item.
*/
let filteri: (t<'a>, ('a, int) => bool) => t<'a>

/**
`filterMap(source, mapper)` builds a new sequence containing only the items for
which the `mapper` callback returns `Some`.
*/
let filterMap: (t<'a>, 'a => option<'b>) => t<'b>

/**
`filterMap(source, mapper)` builds a new sequence containing only the items for
which the `mapper` callback returns `Some`. The callback receives the zero-based
index of each item.
*/
let filterMapi: (t<'a>, ('a, int) => option<'b>) => t<'b>

/**
`filterSome` is the sequence of all the `Some` items in the source sequence.
`None` items are discarded.
*/
let filterSome: t<option<'a>> => t<'a>

/**
`filterOk` is the sequence of all the `Ok` items in the source sequence. `Error`
items are discarded.
*/
let filterOk: t<result<'a, 'b>> => t<'a>

/**
`take(source, count)` is the sequence of the first `count` items of `source`, or
fewer if `source` ends sooner. Remaining items are discarded.
*/
let take: (t<'a>, int) => t<'a>

/**
`takeWhile(source, predicate)` is the sequence that includes all items from the
beginning of `source` up to **but not including** the item where `predicate` is
`false`. See `takeUntil` to include that last item.
*/
let takeWhile: (t<'a>, 'a => bool) => t<'a>

/**
`takeUntil(source, predicate)` is the sequence that includes all items from the
beginning of `source` up to **and including** the first item where `predicate` is
`false`. See `takeWhile` to exclude that last item.
*/
let takeUntil: (t<'a>, 'a => bool) => t<'a>

/**
`drop(source, count)` is the sequence that begins after the first `count`
items are discarded from `source`. If the sequence has less than or equal to
`count` items, returns an empty sequence. 
*/
let drop: (t<'a>, int) => t<'a>

/**
`dropWhile(source, predicate)` is the sequence that skips items from the
beginning of `source` and **starts** at the first item where predicate is
`false`. See `dropUntil` to include the last `true` item.
*/
let dropWhile: (t<'a>, 'a => bool) => t<'a>

/**
`dropUntil(source, predicate)` is the sequence that skips items from the
beginning of `source` and **starts** at the first item where predicate is
`true`. See `dropWhile` to exclude the first `true` item.
*/
let dropUntil: (t<'a>, 'a => bool) => t<'a>

/**
`scan(source, zero, accumulator)` is conceptually related to `reduce`. However
instead of performing an eager evaluation and returning the final accumulated
value, it returns a sequence of accumulated values (partial sums).
*/
let scan: (t<'a>, 'b, ('b, 'a) => 'b) => t<'b>

/**
`cache` memoizes the values in a sequence. This is typically useful when
repeatedly evaluating items in the original sequence is computationally
expensive or if iterating the sequence causes side-effects that the user does
not want to be repeated multiple times.
*/
let cache: t<'a> => t<'a>

/**
`tap` inserts a listener into the middle of a sequence so side-effects, like
logging and debugging, can be performed. It returns the original sequence
without modification. 
*/
let tap: (t<'a>, 'a => unit) => t<'a>

/**
`chunkBySize(source, size)` divides the input sequence into non-overlapping
arrays of adjacent items with at most `size` items in each. The final chunk
might have fewer than `size` items.
*/
let chunkBySize: (t<'a>, int) => t<array<'a>>

/**
`pairwise` is the sequence of each element and its predecessor, with the
exception of the first element that is only returned as the predecessor of the
second. Returns the empty sequence if the source only has a single item.

Also see `pairAhead` and `pairBehind`.
*/
let pairwise: t<'a> => t<('a, 'a)>

/**
`window(source, size)` returns a sequence of sliding overlapping windows of the
specified size containing elements drawn from `source`. If `size` is longer than
`source`, no windows are returned.

**Note:** Each window is not guaranteed to be a separate fresh array. Consider
calling `map` to copy each window if you need distinct array instances.
*/
let window: (t<'a>, int) => t<array<'a>>

/**
`allPairs(seq1, seq2)` contains all pairings of items from the first and second
sequences. This is also known as a cartesian product.

To combine sequences item-by-item until one sequence ends, see `zip` and `map2`.
*/
let allPairs: (t<'a>, t<'b>) => t<('a, 'b)>

/**
`intersperse(separator)` is the sequence formed by inserting `separator` between
each pair of items in the input sequence. If the input sequence is empty or has
a single value it is not modified. See `intersperseWith` if the separator needs
to be computed or might be different each time it is used.
*/
let intersperse: (t<'a>, 'a) => t<'a>

/**
`intersperseWith(separator)` is the sequence formed by inserting a computed
`separator` between each pair of items in the input sequence. If the input
sequence is empty or has a single value it is not modified. See `intersperse` if
the separator is a constant value.
*/
let intersperseWith: (t<'a>, unit => 'a) => t<'a>

/**
`orElse(source, otherwise)` is the `source` unless it is empty, in which case
`otherwise` is substituted as a fallback.
*/
let orElse: (t<'a>, t<'a>) => t<'a>

/**
`map2(seq1, seq2, mapper)` is the sequence formed by applying the `mapper`
function to corresponding items from the source sequences. If one sequence ends
before the other, the remaining items in the longer sequence are ignored.
*/
let map2: (t<'a>, t<'b>, ('a, 'b) => 'c) => t<'c>

/**
`map3(seq1, seq2, seq3, mapper)` is the sequence formed by applying the `mapper`
function to corresponding items from the source sequences. If one sequence ends
before any of the others, the remaining items in the longer sequences are
ignored.
*/
let map3: (t<'a>, t<'b>, t<'c>, ('a, 'b, 'c) => 'd) => t<'d>

/**
`map4(seq1, seq2, seq3, seq4, mapper)` is the sequence formed by applying the
`mapper` function to corresponding items from the source sequences. If one
sequence ends before any of the others, the remaining items in the longer
sequences are ignored.
*/
let map4: (t<'a>, t<'b>, t<'c>, t<'d>, ('a, 'b, 'c, 'd) => 'e) => t<'e>

/**
`map5(seq1, seq2, seq3, seq4, seq5, mapper)` is the sequence formed by applying
the `mapper` function to corresponding items from the source sequences. If one
sequence ends before any of the others, the remaining items in the longer
sequences are ignored.
*/
let map5: (t<'a>, t<'b>, t<'c>, t<'d>, t<'e>, ('a, 'b, 'c, 'd, 'e) => 'f) => t<'f>

/**
`zip(seq1, seq2, mapper)` is the sequence formed by combining corresponding
items from the source sequences into a tuple. If one sequence ends before the
other, the remaining items in the longer sequence are ignored.
*/
let zip: (t<'a>, t<'b>) => t<('a, 'b)>

/**
`zip3(seq1, seq2, seq3, mapper)` is the sequence formed by combining corresponding
items from the source sequences into a tuple. If one sequence ends before any of
the others, the remaining items in the longer sequences are ignored.
*/
let zip3: (t<'a>, t<'b>, t<'c>) => t<('a, 'b, 'c)>

/**
`zip4(seq1, seq2, seq3, seq4, mapper)` is the sequence formed by combining
corresponding items from the source sequences into a tuple. If one sequence ends
before any of the others, the remaining items in the longer sequences are
ignored.
*/
let zip4: (t<'a>, t<'b>, t<'c>, t<'d>) => t<('a, 'b, 'c, 'd)>

/**
`zip5(seq1, seq2, seq3, seq4, seq5, mapper)` is the sequence formed by combining
corresponding items from the source sequences into a tuple. If one sequence ends
before any of the others, the remaining items in the longer sequences are
ignored.
*/
let zip5: (t<'a>, t<'b>, t<'c>, t<'d>, t<'e>) => t<('a, 'b, 'c, 'd, 'e)>

/**
`sortedMerge(seq1, seq2, compare)` takes two **sorted** sequences and merges
them into a single **sorted** sequence based on the `compare` function. Once one
of the sequences are exhaused, all the remaining items from the other sequence
are included. 
*/
let sortedMerge: (t<'a>, t<'a>, ('a, 'a) => int) => t<'a>

/**
`interleave(seq1, seq2)` is the sequence built by alternately taking items from `seq1`
and `seq2`. When one of those sequences is empty, the remaining items from the
other sequence are included.
*/
let interleave: (t<'a>, t<'a>) => t<'a>

/**
`reduce(source, zero, accumulator)` invokes `accumulator` successively for every
item in `source`, starting with the `zero` value, and returns the final result.

Reducing (also known as folding) is useful when you have a collection of
something and want to produce a single value from it. 
*/
let reduce: (t<'a>, 'b, ('b, 'a) => 'b) => 'b

/**
`reduceUntil(source, zero, accumulator, predicate)` invokes `accumulator`
successively for items in `source`, starting with the `zero` value. The
computation stops after `source` is exhausted, or after `predicate` applied to
`zero` or the current accumulated result is `true`. Returns the first result
where `predicate` is `true` or the final computed value if `predicate` is always
`false`.
*/
let reduceUntil: (t<'a>, 'b, ('b, 'a) => 'b, 'b => bool) => 'b

/**
`reduceWhile(source, zero, accumulator, predicate)` invokes `accumulator`
successively for items in `source`, starting with the provided `zero` value. The
computation stops after `source` is exhausted, or after `predicate` applied to
`zero` or the current accumulated result is `false`. Returns the last result,
if any, where `predicate` is `true`.
*/
let reduceWhile: (t<'a>, 'b, ('b, 'a) => 'b, 'b => bool) => option<'b>

/**
`sumBy(source, accumulator)` invokes `accumulator(sum, item)` successively for
every item in `source`, starting with the first pair of items, and returns the
final result. If `source` has a single item, that value becomes the final result
and `accumulator` is not used. If `source` is empty, returns `None.`

This function is not limited to adding numbers; the `accumulator` can
concatenate strings, append arrays, perform logical operations on booleans, etc.

See `reduce` for a function that takes an initial value and can compute a value
of a different type than items in `source`.
*/
let sumBy: (t<'a>, ('a, 'a) => 'a) => option<'a>

/**
`prefixSum(source, accumulator)` calculates the running totals for each item
in `source`. The first item in `source` becomes the first sum in the result.
Subsequent results are computed by `accumulator(sum, item)`. If `source` is
empty, the result is empty.

This function is not limited to adding numbers; the `accumulator` can
concatenate strings, append arrays, perform logical operations on booleans, etc.

See `scan` for a function that takes an initial value and can generate values of
a different type than the source.
*/
let prefixSum: (t<'a>, ('a, 'a) => 'a) => t<'a>

/**
`forEach(source, f)` eagerly applies `f` to each item in the sequence. This does
not return any value. It is useful for performing side-effects like logging
values to the console.
*/
let forEach: (t<'a>, 'a => unit) => unit

/**
`forEachi(source, f)` eagerly applies `f` to each item in the sequence. The
callback receives the zero-based index of each item. This does not return any
value. It is useful for performing side-effects like logging values to the
console.
*/
let forEachi: (t<'a>, ('a, int) => unit) => unit

/**
`some(source, predicate)` returns `true` if there exists at least one item where
the supplied predicate is `true`. Returns `false` for an empty sequence or when
no item satisfies the predicate.
*/
let some: (t<'a>, 'a => bool) => bool

/**
`every(source, predicate)` returns `true` if the input sequence is empty or the
supplied predicate is `true` for every item. Analogous to the `for all`
existential quantifier in mathematics.
*/
let every: (t<'a>, 'a => bool) => bool

/**
`find(source, predicate)` tries to find the first item where `predicate` is
`true`. Returns `None` for an empty sequence or if no such item can be found.
*/
let find: (t<'a>, 'a => bool) => option<'a>

/**
`findLast(source, predicate)` tries to find the last item where `predicate` is
`true`. Returns `None` for an empty sequence or if no such item can be found.
*/
let findLast: (t<'a>, 'a => bool) => option<'a>

/**
`findMap(source, mapper)` tries to find the first item where `mapper` returns
`Some`. Returns `None` for an empty sequence or if no such item can be found.
*/
let findMap: (t<'a>, 'a => option<'b>) => option<'b>

/**
`findMapLast(source, mapper)` tries to find the last item where `mapper` returns
`Some`. Returns `None` for an empty sequence or if no such item can be found.
*/
let findMapLast: (t<'a>, 'a => option<'b>) => option<'b>

/**
`length` returns the number of items in the sequence. **Note:** This requires
eagerly iterating through every item.
*/
let length: t<'a> => int

/**
`isEmpty` determines if the sequence has any items in it.
*/
let isEmpty: t<'a> => bool

/**
`isSortedBy(source, compare)` determines if the sequence is sorted according to
the provided compare function. Returns `true` for an empty sequence.
*/
let isSortedBy: (t<'a>, ('a, 'a) => int) => bool

/**
`equals(seq1, seq2, areEqual)` determines if two sequences have exactly the same
length and corresponding items in each sequence are equal according to the
`areEqual` function.
*/
let equals: (t<'a>, t<'a>, ('a, 'a) => bool) => bool

/**
`compare(seq1, seq2, compare)` compares two sequences using the given comparison
function, item by item. Returns the first non-zero result. If the end of a
sequence is reached it return -1 if the first sequence is shorter and 1 if the
second sequence is shorter.
*/
let compare: (t<'a>, t<'a>, ('a, 'a) => int) => int

/**
`head` is the first item in the sequence. Returns `None` if the sequence is
empty.
*/
let head: t<'a> => option<'a>

/**
`tail` is the sequence (possibly empty) that starts after the head (first item).
Equivalent to `drop` with `1`.
*/
let tail: t<'a> => t<'a>

/**
`tails` is the sequence of all tails of a sequence, from longest to shortest,
starting with the original list itself. **Note:** The empty sequence is the last
(and obviously shortest) item in the sequence.

```rescript
tails([]) // [[]]
tails([1, 2, 3]) // [[1, 2, 3], [2,3], [3], []]
```
*/
let tails: t<'a> => t<t<'a>>

/**
`dropLast(source, count)` contains the items from `source` with the last `count`
items omitted. If `count` is zero, `source` is returned without any
modifications. If `count` exceeds the number of items in `source`, returns an
empty sequence. 
*/
let dropLast: (t<'a>, int) => t<'a>

/**
`uncons` splits ("un-constructs") the the sequence into its head (first item)
and the tail, which is possibly empty. If the sequence is empty, it returns
`None`.
*/
let uncons: t<'a> => option<('a, t<'a>)>

/**
`minBy(seq, compare)` eagerly consumes the entire sequence and returns the
minimum item according to the `compare` function. Returns `None` if the
sequence is empty.
*/
let minBy: (t<'a>, ('a, 'a) => int) => option<'a>

/**
`maxBy(seq, compare)` eagerly consumes the entire sequence and returns the
maximum item according to the `compare` function. Returns `None` if the
sequence is empty.
*/
let maxBy: (t<'a>, ('a, 'a) => int) => option<'a>

/**
`last` eagerly consumes the entire sequence and returns a `Some` for the last
item, or `None` if the sequence is empty.
*/
let last: t<'a> => option<'a>

/**
`toArray` eagerly consumes the entire sequence and converts it to an array.
*/
let toArray: t<'a> => array<'a>

/**
`toList` eagerly consumes the entire sequence and converts it to a list with
items in the same order.
*/
let toList: t<'a> => list<'a>

/**
`join(parts, separator)` concatenates every string in `parts`, separated by
`separator`; use an empty string if no separator is desired. If `parts` is
empty, returns an empty string. If `parts` has only one string, that string is
returned without using the `separator`.
*/
let join: (t<string>, string) => string

/**
`exactlyOne` checks if the sequence has exactly one item in it, and if so
returns it as `Some`.
*/
let exactlyOne: t<'a> => option<'a>

/**
`toOption` checks if the sequence is empty and if so returns `None`. Otherwise
returns a `Some` non-empty sequence.
*/
let toOption: t<'a> => option<t<'a>>

/**
`everyOk` returns an `Ok` sequence if all the input items are `Ok` or if the
input sequence is empty. Otherwise returns the first `Error`. This is useful for
lazy validation because validation stops when the first `Error` is encountered.
*/
let everyOk: t<result<'ok, 'err>> => result<t<'ok>, 'err>

/**
`everySome` returns a `Some` sequence if all input items are `Some` or if the
input sequence is empty. Otherwise returns `None.`
*/
let everySome: t<option<'a>> => option<t<'a>>

/**
`consume` eagerly iterates through every item in the sequence and returns
nothing. This is useful if side-effects are performed via `tap` or other
functions in the pipeline. Equivalent to `forEach` where the supplied function
does nothing.
*/
let consume: t<'a> => unit

/**
`reverse(source)` converts the entire sequence to a new array and returns a
sequence corresponding to the items in the reverse order. If `source` is never
iterated then nothing happens.
*/
let reverse: t<'a> => t<'a>

/**
`delay` returns a sequence that is built from the given lazy specifcation of a
sequence.
*/
let delay: (unit => t<'a>) => t<'a>

/**
`sortBy(source, compare)` consumes the entire `source` sequence as soon as that
sequence is iterated. As such it should not be used with large or infinite
sequences. The function uses a stable sort (the original order of equal elements
is preserved) based on the provided `compare` function.
*/
let sortBy: (t<'a>, ('a, 'a) => int) => t<'a>

/**
`combinations(source, size)` generates all combinations of items in `source`,
based on their indexed position (not value), from 1 to `size` items in length.
Each combination is returned as a `(size, sequence)` tuple. A combination is a
unique set; the order in which items are listed is immaterial. 
*/
let combinations: (t<'a>, int) => t<(int, t<'a>)>

/** 
`permutations(source, size)` generates all permutations (ordered arrangements)
of items in `source` based on their indexed position (not value), from 1 to
`size` items in length. Each permutation is returned as a `(size, sequence)`
tuple. 
*/
let permutations: (t<'a>, int) => t<(int, t<'a>)>

/**
`split(source, init, accumulator)` divides `source` into non-overlapping
groups of adjacent items, computes (via reduce) a "total" of some kind for each
group, and then returns a sequence of group "totals".

The first group is created by passing the first item to `init`. The
`accumulator` is then called with subsequent items. If `accumulator` returns
`Some`, the current group is updated to incorporate the new item. If
`accumulator` returns `None`, that signifies the group is complete, and a new
group is then created using the `init` function.

**Note:** This function lazily operates on adjacent items. It does not summarize
data across the entire sequence. If you want to summarize all the data, consider
first sorting the data. Or use `reduce` to convert the data to a dictionary.
*/
let split: (t<'a>, 'a => 'b, ('b, 'a) => option<'b>) => t<'b>

/**
`pairAhead(source)` is the sequence of every item in `source` paired with the
item that follows it.
*/
let pairAhead: t<'a> => t<('a, option<'a>)>

/**
`pairBehind(source)` is the sequence of every item in `source` paired with
the item that precedes it.
*/
let pairBehind: t<'a> => t<(option<'a>, 'a)>

/**
`neighbors(source)` is the sequence of each item in `source` with the
items that immediately precede and follow it.
*/
let neighbors: t<'a> => t<(option<'a>, 'a, option<'a>)>
